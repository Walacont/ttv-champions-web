<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <!-- Cookie Consent & Analytics -->
    <script src="/js/cookie-consent.js"></script>
    <script src="/js/capacitor-init.js"></script>
        <script src="/js/avatar-utils.js"></script>
        <script src="/js/i18n-lite.js"></script>
        <script src="/js/analytics.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H2R9ZJYQ06"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'G-H2R9ZJYQ06');
    </script>

    <title>Video Labeling - SC Champions Admin</title>
    <link rel="stylesheet" href="/css/tailwind.css" />
    <link rel="stylesheet" href="/vendor/fontawesome/css/all.min.css">
    <style>
        .time-input::-webkit-inner-spin-button,
        .time-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .shot-item:hover .delete-shot {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- Header -->
    <header class="bg-indigo-600 text-white shadow-lg">
        <div class="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <i class="fas fa-robot text-2xl"></i>
                <div>
                    <h1 class="text-xl font-bold">Video Labeling</h1>
                    <p class="text-indigo-200 text-sm">ML-Training Daten vorbereiten</p>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <div id="stats" class="text-sm text-indigo-200">
                    <span id="pending-count">0</span> Videos warten
                </div>
                <button id="logout-btn" class="text-indigo-200 hover:text-white">
                    <i class="fas fa-sign-out-alt mr-1"></i>Abmelden
                </button>
            </div>
        </div>
    </header>

    <!-- Statistik-Leiste -->
    <div class="bg-white border-b shadow-sm">
        <div class="max-w-7xl mx-auto px-4 py-3">
            <div class="flex flex-wrap items-center justify-between gap-4 text-sm">
                <div class="flex flex-wrap items-center gap-4">
                    <span class="text-gray-600 font-medium">Gelabelte Videos:</span>
                    <div class="flex flex-wrap gap-3">
                        <span class="inline-flex items-center gap-1 px-2 py-1 bg-yellow-100 text-yellow-800 rounded">
                            üéæ Balleimer: <strong id="stat-ballmaschine">0</strong>
                        </span>
                        <span class="inline-flex items-center gap-1 px-2 py-1 bg-green-100 text-green-800 rounded">
                            üèì Spiel: <strong id="stat-match">0</strong>
                        </span>
                        <span class="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded">
                            üìã √úbung: <strong id="stat-exercise">0</strong>
                        </span>
                        <span class="inline-flex items-center gap-1 px-2 py-1 bg-purple-100 text-purple-800 rounded">
                            üéØ Freies Training: <strong id="stat-freeplay">0</strong>
                        </span>
                        <span class="inline-flex items-center gap-1 px-2 py-1 bg-gray-100 text-gray-800 rounded">
                            üìä Gesamt: <strong id="stat-total">0</strong>
                        </span>
                    </div>
                </div>
                <!-- Export Buttons -->
                <div class="flex gap-2">
                    <button id="export-csv-btn" class="px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded-lg flex items-center gap-1">
                        <i class="fas fa-file-csv"></i> CSV Export
                    </button>
                    <button id="export-json-btn" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded-lg flex items-center gap-1">
                        <i class="fas fa-file-code"></i> JSON Export
                    </button>
                    <button id="export-roboflow-btn" class="px-3 py-1.5 bg-purple-600 hover:bg-purple-700 text-white text-xs rounded-lg flex items-center gap-1" title="Frames + Bounding Boxes fur ML-Training exportieren">
                        <i class="fas fa-brain"></i> ML-Training Export
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto p-4">
        <!-- Video Feed (wenn kein Video ausgew√§hlt) -->
        <div id="video-feed" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <!-- Videos werden hier dynamisch eingef√ºgt -->
            <div class="col-span-full text-center py-12 text-gray-500">
                <i class="fas fa-spinner fa-spin text-4xl mb-4"></i>
                <p>Videos werden geladen...</p>
            </div>
        </div>

        <!-- Labeling Interface (wenn Video ausgew√§hlt) -->
        <div id="labeling-interface" class="hidden">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Links: Video -->
                <div class="lg:col-span-2">
                    <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                        <div class="bg-gray-900 p-2 flex justify-between items-center">
                            <button id="back-to-feed" class="text-white hover:text-gray-300 px-3 py-1 text-sm">
                                <i class="fas fa-arrow-left mr-1"></i>Zur√ºck zur Liste
                            </button>
                            <span id="video-title" class="text-white text-sm truncate"></span>
                            <div class="text-gray-400 text-sm">
                                <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
                            </div>
                        </div>
                        <div class="relative">
                            <video id="label-video" class="w-full bg-black" controls crossorigin="anonymous" playsinline>
                                <source src="" type="video/mp4">
                            </video>
                            <canvas id="video-overlay" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="z-index:10"></canvas>
                        </div>

                        <!-- Overlay-Toggles -->
                        <div class="flex items-center gap-2 px-4 py-2 bg-gray-800 border-t border-gray-700">
                            <span class="text-xs text-gray-400 mr-1">Einblenden:</span>
                            <button id="toggle-skeleton" class="overlay-toggle text-xs px-2 py-1 rounded border border-gray-600 text-gray-400 hover:text-white hover:border-gray-400 transition-colors" data-active="false">
                                <i class="fas fa-walking mr-1"></i>Skelett
                            </button>
                            <button id="toggle-table" class="overlay-toggle text-xs px-2 py-1 rounded border border-gray-600 text-gray-400 hover:text-white hover:border-gray-400 transition-colors" data-active="false">
                                <i class="fas fa-square mr-1"></i>Tisch
                            </button>
                            <button id="toggle-ball" class="overlay-toggle text-xs px-2 py-1 rounded border border-gray-600 text-gray-400 hover:text-white hover:border-gray-400 transition-colors" data-active="false">
                                <i class="fas fa-circle mr-1"></i>Ball
                            </button>
                            <div class="ml-auto">
                                <button id="btn-calibrate-table" class="text-xs px-2 py-1 rounded border border-yellow-600 text-yellow-400 hover:text-yellow-200 hover:border-yellow-400 transition-colors">
                                    <i class="fas fa-crosshairs mr-1"></i>Tisch kalibrieren
                                </button>
                            </div>
                        </div>
                        <!-- Kalibrierungs-Anleitung (versteckt) -->
                        <div id="calibration-bar" class="hidden px-4 py-2 bg-yellow-900/80 border-t border-yellow-700 flex items-center gap-3">
                            <i class="fas fa-info-circle text-yellow-400"></i>
                            <span id="calibration-instruction" class="text-xs text-yellow-200 flex-1">Klicke die 4 Ecken des Tisches im Uhrzeigersinn (oben-links zuerst)</span>
                            <span id="calibration-count" class="text-xs text-yellow-400 font-mono">0/4</span>
                            <button id="btn-calibration-undo" class="text-xs px-2 py-1 rounded border border-yellow-700 text-yellow-400 hover:text-yellow-200">
                                <i class="fas fa-undo mr-1"></i>Zur√ºck
                            </button>
                            <button id="btn-calibration-cancel" class="text-xs px-2 py-1 rounded border border-red-700 text-red-400 hover:text-red-200">
                                <i class="fas fa-times mr-1"></i>Abbrechen
                            </button>
                        </div>

                        <!-- Zeitleiste mit Markierungen -->
                        <div class="p-4 bg-gray-50 border-t">
                            <div class="relative h-8 bg-gray-200 rounded-full overflow-hidden cursor-pointer" id="timeline">
                                <!-- Shot-Markierungen werden hier eingef√ºgt -->
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0:00</span>
                                <span id="timeline-end">0:00</span>
                            </div>
                        </div>
                    </div>

                    <!-- Coach-Kommentare -->
                    <div class="bg-white rounded-xl shadow-lg mt-4 p-4">
                        <h3 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                            <i class="fas fa-comments text-indigo-500"></i>
                            Coach-Kommentare
                        </h3>
                        <div id="coach-comments" class="space-y-2 max-h-48 overflow-y-auto">
                            <!-- Kommentare werden hier eingef√ºgt -->
                        </div>
                    </div>
                </div>

                <!-- Rechts: Labeling Form -->
                <div class="space-y-4">
                    <!-- Video-Info Panel -->
                    <div class="bg-white rounded-xl shadow-lg p-4">
                        <h3 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                            <i class="fas fa-info-circle text-blue-500"></i>
                            Video-Info
                        </h3>

                        <!-- Video-Typ -->
                        <div class="mb-3">
                            <label class="text-xs text-gray-600 block mb-1">Video-Typ</label>
                            <div class="flex flex-wrap gap-1">
                                <button type="button" data-vtype="ballmaschine"
                                        class="vtype-btn px-2 py-1 text-xs rounded border border-gray-300 bg-white hover:bg-blue-50 transition-colors">
                                    üéæ Balleimer
                                </button>
                                <button type="button" data-vtype="match"
                                        class="vtype-btn px-2 py-1 text-xs rounded border border-gray-300 bg-white hover:bg-blue-50 transition-colors">
                                    üèì Spiel
                                </button>
                                <button type="button" data-vtype="exercise"
                                        class="vtype-btn px-2 py-1 text-xs rounded border border-gray-300 bg-white hover:bg-blue-50 transition-colors">
                                    üìã √úbung
                                </button>
                                <button type="button" data-vtype="freeplay"
                                        class="vtype-btn px-2 py-1 text-xs rounded border border-gray-300 bg-white hover:bg-blue-50 transition-colors">
                                    üéØ Freies Training
                                </button>
                            </div>
                        </div>

                        <!-- √úbungs-Auswahl (nur wenn video_type = exercise) -->
                        <div id="exercise-selection" class="mb-3 hidden">
                            <label class="text-xs text-gray-600 block mb-1">√úbung aus Datenbank</label>
                            <select id="exercise-select" class="w-full px-2 py-1.5 text-sm border border-gray-300 rounded">
                                <option value="">-- √úbung ausw√§hlen --</option>
                            </select>
                        </div>

                        <!-- Info wenn vom Upload bereits gesetzt -->
                        <div id="upload-info" class="hidden">
                            <div class="bg-blue-50 rounded-lg p-2 text-xs">
                                <p class="font-medium text-blue-800 mb-1">
                                    <i class="fas fa-check-circle mr-1"></i>Vom Upload festgelegt:
                                </p>
                                <p id="upload-exercise-name" class="text-blue-700"></p>
                            </div>
                        </div>
                    </div>

                    <!-- KI-Voranalyse -->
                    <div class="bg-white rounded-xl shadow-lg p-4">
                        <h3 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                            <i class="fas fa-robot text-cyan-500"></i>
                            KI-Voranalyse
                        </h3>
                        <p class="text-xs text-gray-500 mb-3">KI erkennt automatisch Schl√§ge. Du korrigierst falsche Erkennungen - das verbessert die KI.</p>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <button id="ai-analyze-btn"
                                    class="flex-1 bg-cyan-600 hover:bg-cyan-700 text-white font-medium py-2 px-3 rounded-lg transition-colors flex items-center justify-center gap-2">
                                <i class="fas fa-magic"></i>
                                Schl√§ge erkennen
                            </button>
                            <button id="ai-table-ball-btn"
                                    class="flex-1 bg-teal-600 hover:bg-teal-700 text-white font-medium py-2 px-3 rounded-lg transition-colors flex items-center justify-center gap-2">
                                <i class="fas fa-table-tennis"></i>
                                Tisch &amp; Ball
                            </button>
                        </div>
                        <div id="ai-table-ball-info" class="hidden mt-2 p-2 bg-teal-50 rounded-lg border border-teal-200 text-xs">
                            <div id="ai-table-info" class="text-gray-600"></div>
                            <div id="ai-ball-info" class="text-gray-600 mt-1"></div>
                        </div>
                        <div id="ai-progress" class="hidden mt-3">
                            <div class="flex justify-between text-xs text-gray-600 mb-1">
                                <span id="ai-progress-text">Lade KI-Modell...</span>
                                <span id="ai-progress-percent">0%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div id="ai-progress-bar" class="bg-cyan-600 h-2 rounded-full transition-all" style="width: 0%"></div>
                            </div>
                            <button id="ai-cancel-btn" class="mt-2 text-xs text-red-500 hover:text-red-700">
                                <i class="fas fa-times mr-1"></i>Abbrechen
                            </button>
                        </div>
                        <!-- Spieler-Zuordnung (erscheint nach Analyse) -->
                        <div id="ai-players" class="hidden mt-3 border border-gray-200 rounded-lg p-3 bg-gray-50">
                            <h4 class="text-xs font-semibold text-gray-700 mb-2 flex items-center gap-1">
                                <i class="fas fa-users text-gray-500"></i>
                                Spieler-Zuordnung
                            </h4>
                            <div id="ai-players-list" class="space-y-2">
                                <!-- Wird dynamisch bef√ºllt -->
                            </div>
                            <button id="ai-reclassify-btn" class="mt-2 w-full bg-cyan-100 hover:bg-cyan-200 text-cyan-700 text-xs font-medium py-1.5 px-3 rounded transition-colors">
                                <i class="fas fa-sync-alt mr-1"></i>Neu klassifizieren
                            </button>
                        </div>

                        <!-- KI-Vorschl√§ge Liste -->
                        <div id="ai-suggestions" class="hidden mt-3">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-medium text-gray-600">KI-Vorschl√§ge</span>
                                <div class="flex gap-1">
                                    <button id="ai-accept-all-btn" class="text-xs bg-green-100 hover:bg-green-200 text-green-700 px-2 py-0.5 rounded">
                                        Alle √ºbernehmen
                                    </button>
                                    <button id="ai-clear-btn" class="text-xs bg-red-100 hover:bg-red-200 text-red-700 px-2 py-0.5 rounded">
                                        Verwerfen
                                    </button>
                                </div>
                            </div>
                            <div id="ai-suggestions-list" class="space-y-1 max-h-64 overflow-y-auto">
                            </div>
                        </div>
                    </div>

                    <!-- Neuen Schlag hinzuf√ºgen -->
                    <div class="bg-white rounded-xl shadow-lg p-4">
                        <h3 class="font-bold text-gray-800 mb-4 flex items-center gap-2">
                            <i class="fas fa-plus-circle text-green-500"></i>
                            Schlag markieren
                        </h3>

                        <!-- Zeit-Eingabe (mit Millisekunden) -->
                        <div class="grid grid-cols-2 gap-3 mb-4">
                            <div>
                                <label class="text-xs text-gray-600 block mb-1">Start</label>
                                <div class="flex items-center gap-1">
                                    <input type="number" id="shot-start-min" min="0" max="59" value="0"
                                           class="time-input w-10 px-1 py-2 border border-gray-300 rounded text-center text-sm">
                                    <span>:</span>
                                    <input type="number" id="shot-start-sec" min="0" max="59" value="0"
                                           class="time-input w-10 px-1 py-2 border border-gray-300 rounded text-center text-sm">
                                    <span>.</span>
                                    <input type="number" id="shot-start-ms" min="0" max="999" value="0"
                                           class="time-input w-12 px-1 py-2 border border-gray-300 rounded text-center text-sm" placeholder="ms">
                                    <button id="set-start-current" class="px-2 py-2 bg-gray-100 hover:bg-gray-200 rounded text-xs" title="Aktuelle Position">
                                        <i class="fas fa-crosshairs"></i>
                                    </button>
                                </div>
                            </div>
                            <div>
                                <label class="text-xs text-gray-600 block mb-1">Ende</label>
                                <div class="flex items-center gap-1">
                                    <input type="number" id="shot-end-min" min="0" max="59" value="0"
                                           class="time-input w-10 px-1 py-2 border border-gray-300 rounded text-center text-sm">
                                    <span>:</span>
                                    <input type="number" id="shot-end-sec" min="0" max="59" value="0"
                                           class="time-input w-10 px-1 py-2 border border-gray-300 rounded text-center text-sm">
                                    <span>.</span>
                                    <input type="number" id="shot-end-ms" min="0" max="999" value="0"
                                           class="time-input w-12 px-1 py-2 border border-gray-300 rounded text-center text-sm" placeholder="ms">
                                    <button id="set-end-current" class="px-2 py-2 bg-gray-100 hover:bg-gray-200 rounded text-xs" title="Aktuelle Position">
                                        <i class="fas fa-crosshairs"></i>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Position: Von wo / Nach wo -->
                        <div class="mb-4 grid grid-cols-2 gap-3">
                            <div>
                                <label class="text-xs text-gray-600 block mb-1">Von (Spieler)</label>
                                <div class="flex rounded-lg border border-gray-300 overflow-hidden">
                                    <button type="button" data-from="vh"
                                            class="from-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-indigo-50 transition-colors">
                                        VH
                                    </button>
                                    <button type="button" data-from="mitte"
                                            class="from-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-gray-50 transition-colors border-l">
                                        Mitte
                                    </button>
                                    <button type="button" data-from="rh"
                                            class="from-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-purple-50 transition-colors border-l">
                                        RH
                                    </button>
                                </div>
                            </div>
                            <div>
                                <label class="text-xs text-gray-600 block mb-1">Nach (Gegner)</label>
                                <div class="flex rounded-lg border border-gray-300 overflow-hidden">
                                    <button type="button" data-to="vh"
                                            class="to-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-indigo-50 transition-colors">
                                        VH
                                    </button>
                                    <button type="button" data-to="mitte"
                                            class="to-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-gray-50 transition-colors border-l">
                                        Mitte
                                    </button>
                                    <button type="button" data-to="rh"
                                            class="to-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-purple-50 transition-colors border-l">
                                        RH
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Schlagtyp -->
                        <div class="mb-4">
                            <label class="text-xs text-gray-600 block mb-1">Schlagtyp</label>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <p class="text-xs text-indigo-600 font-medium mb-1">Vorhand</p>
                                    <div class="space-y-1">
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-indigo-500 text-left" data-type="forehand_serve">
                                            VH Aufschlag
                                        </button>
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-indigo-500 text-left" data-type="forehand_topspin">
                                            VH Topspin
                                        </button>
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-indigo-500 text-left" data-type="forehand_push">
                                            VH Schupf
                                        </button>
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-indigo-500 text-left" data-type="forehand_block">
                                            VH Block
                                        </button>
                                    </div>
                                </div>
                                <div>
                                    <p class="text-xs text-purple-600 font-medium mb-1">R√ºckhand</p>
                                    <div class="space-y-1">
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-purple-500 text-left" data-type="backhand_serve">
                                            RH Aufschlag
                                        </button>
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-purple-500 text-left" data-type="backhand_topspin">
                                            RH Topspin
                                        </button>
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-purple-500 text-left" data-type="backhand_push">
                                            RH Schupf
                                        </button>
                                        <button class="shot-type-btn w-full px-2 py-1.5 text-xs border border-gray-300 rounded hover:border-purple-500 text-left" data-type="backhand_block">
                                            RH Block
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Ergebnis -->
                        <div class="mb-4">
                            <label class="text-xs text-gray-600 block mb-1">Ergebnis</label>
                            <div class="flex rounded-lg border border-gray-300 overflow-hidden">
                                <button type="button" data-result="hit"
                                        class="result-btn flex-1 px-2 py-2 text-xs bg-green-600 text-white transition-colors">
                                    ‚úì Getroffen
                                </button>
                                <button type="button" data-result="net"
                                        class="result-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-orange-50 transition-colors border-l">
                                    Netz
                                </button>
                                <button type="button" data-result="out"
                                        class="result-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-red-50 transition-colors border-l">
                                    Aus
                                </button>
                                <button type="button" data-result="miss"
                                        class="result-btn flex-1 px-2 py-2 text-xs bg-white hover:bg-gray-100 transition-colors border-l">
                                    Verfehlt
                                </button>
                            </div>
                        </div>

                        <!-- Hinzuf√ºgen Button -->
                        <button id="add-shot-btn"
                                class="w-full bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-plus"></i>
                            Schlag hinzuf√ºgen
                        </button>
                    </div>

                    <!-- Bereits markierte Schl√§ge -->
                    <div class="bg-white rounded-xl shadow-lg p-4">
                        <h3 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                            <i class="fas fa-list text-indigo-500"></i>
                            Markierte Schl√§ge
                            <span id="shot-count" class="bg-indigo-100 text-indigo-700 text-xs px-2 py-0.5 rounded-full">0</span>
                        </h3>
                        <div id="shots-list" class="space-y-2 max-h-64 overflow-y-auto">
                            <p class="text-gray-500 text-sm text-center py-4">Noch keine Schl√§ge markiert</p>
                        </div>
                    </div>

                    <!-- Aktionen -->
                    <div class="bg-white rounded-xl shadow-lg p-4 space-y-3">
                        <button id="verify-btn"
                                class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-check-circle"></i>
                            Verifizieren & Speichern
                        </button>
                        <button id="skip-btn"
                                class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-forward"></i>
                            √úberspringen (ungeeignet)
                        </button>
                    </div>

                    <!-- Keyboard Shortcuts -->
                    <div class="bg-gray-50 rounded-lg p-3 text-xs text-gray-500">
                        <p class="font-medium mb-1">Tastenk√ºrzel:</p>
                        <div class="grid grid-cols-2 gap-1">
                            <span><kbd class="bg-white px-1 rounded">Space</kbd> Play/Pause</span>
                            <span><kbd class="bg-white px-1 rounded">S</kbd> Start setzen</span>
                            <span><kbd class="bg-white px-1 rounded">E</kbd> Ende setzen</span>
                            <span><kbd class="bg-white px-1 rounded">Enter</kbd> Schlag hinzuf√ºgen</span>
                            <span><kbd class="bg-white px-1 rounded">1-8</kbd> Schlagtyp</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Toast Container -->
    <div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>

    <script type="module">
        import { getSupabase } from './js/supabase-init.js';
        import { isAIAvailable, loadModels, analyzeFrameRange, analyzeTableAndBall, saveTableBallResults, loadTableBallResults, POSE_LANDMARKS, POSE_CONNECTIONS } from './js/video-ai-engine.js';
        import { classifyShots } from './js/video-ai-shot-classifier.js';

        let supabase;
        let currentUser;
        let currentVideo = null;
        let currentShots = [];
        let videoPlayer;
        let exercisesList = [];
        let selectedVideoType = null;
        let selectedExerciseId = null;
        let aiSuggestions = []; // KI-erkannte Schl√§ge (noch nicht √ºbernommen)
        let aiAbortController = null;
        let aiFormattedFrames = null; // Gespeicherte Frames f√ºr Neu-Klassifizierung
        let aiDetectedPlayers = []; // [{idx, side:'left'|'right', avgX, spielhand:'right'|'left'|null}]
        let aiTableBox = null;  // {x, y, width, height, confidence}
        let aiBallTrack = [];   // [{time, x, y, score}]

        // Overlay-Einstellungen
        let overlayCanvas = null;
        let overlayCtx = null;
        let showSkeleton = false;
        let showTable = false;
        let showBall = false;

        // Tisch-Kalibrierung (4-Ecken)
        let calibrationMode = false;
        let calibrationCorners = []; // [{x, y}] normalisiert (0-1), max 4
        let savedTableCorners = null; // Gespeicherte 4 Ecken aus DB

        // Video type labels
        const videoTypeLabels = {
            'ballmaschine': 'üéæ Balleimer',
            'match': 'üèì Spiel',
            'exercise': 'üìã √úbung',
            'freeplay': 'üéØ Freies Training',
            'other': 'Sonstiges'
        };

        // Shot type labels for display
        const shotTypeLabels = {
            'forehand_serve': 'VH Aufschlag',
            'backhand_serve': 'RH Aufschlag',
            'forehand_topspin': 'VH Topspin',
            'backhand_topspin': 'RH Topspin',
            'forehand_push': 'VH Schupf',
            'backhand_push': 'RH Schupf',
            'forehand_block': 'VH Block',
            'backhand_block': 'RH Block',
            'other': 'Sonstige'
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            supabase = getSupabase();

            // Check auth
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) {
                window.location.href = '/index.html';
                return;
            }
            currentUser = user;

            // Check if user is admin or labeler (only these roles can access labeling)
            const { data: profile } = await supabase
                .from('profiles')
                .select('role')
                .eq('id', user.id)
                .single();

            if (!profile || !['admin', 'labeler'].includes(profile.role)) {
                showToast('Zugriff verweigert - Nur f√ºr Admins/Labeler', 'error');
                setTimeout(() => {
                    window.location.href = '/index.html';
                }, 1500);
                return;
            }

            // Load exercises for dropdown
            await loadExercises();

            // Load statistics
            loadStats();

            // Load videos
            loadPendingVideos();

            // Setup event listeners
            setupEventListeners();

            // Logout button
            document.getElementById('logout-btn').addEventListener('click', async () => {
                await supabase.auth.signOut();
                window.location.href = '/index.html';
            });
        });

        async function loadStats() {
            // Get count of labeled videos (ai_ready = true) by video_type
            const { data: stats, error } = await supabase
                .from('video_analyses')
                .select('video_type')
                .eq('ai_ready', true);

            if (error) {
                console.error('Error loading stats:', error);
                return;
            }

            // Count by type
            const counts = {
                ballmaschine: 0,
                match: 0,
                exercise: 0,
                freeplay: 0,
                other: 0,
                null: 0
            };

            (stats || []).forEach(v => {
                const type = v.video_type || 'null';
                if (counts.hasOwnProperty(type)) {
                    counts[type]++;
                } else {
                    counts.other++;
                }
            });

            // Update UI
            document.getElementById('stat-ballmaschine').textContent = counts.ballmaschine;
            document.getElementById('stat-match').textContent = counts.match;
            document.getElementById('stat-exercise').textContent = counts.exercise;
            document.getElementById('stat-freeplay').textContent = counts.freeplay;
            document.getElementById('stat-total').textContent = stats?.length || 0;
        }

        async function exportCSV() {
            showToast('Exportiere CSV...', 'info');

            // Get all labeled data
            const { data, error } = await supabase
                .from('video_labels')
                .select(`
                    id,
                    timestamp_start,
                    timestamp_end,
                    shot_type,
                    shot_from,
                    shot_to,
                    shot_result,
                    confidence,
                    created_at,
                    video:video_analyses(
                        id,
                        title,
                        video_url,
                        video_type,
                        exercise_id
                    )
                `)
                .order('created_at');

            if (error) {
                showToast('Export fehlgeschlagen: ' + error.message, 'error');
                return;
            }

            if (!data || data.length === 0) {
                showToast('Keine Daten zum Exportieren', 'warning');
                return;
            }

            // Build CSV
            const headers = [
                'label_id',
                'video_id',
                'video_title',
                'video_url',
                'video_type',
                'timestamp_start',
                'timestamp_end',
                'duration_ms',
                'shot_type',
                'shot_from',
                'shot_to',
                'shot_result',
                'confidence',
                'created_at'
            ];

            const rows = data.map(row => [
                row.id,
                row.video?.id || '',
                `"${(row.video?.title || '').replace(/"/g, '""')}"`,
                row.video?.video_url || '',
                row.video?.video_type || '',
                row.timestamp_start,
                row.timestamp_end,
                Math.round((row.timestamp_end - row.timestamp_start) * 1000),
                row.shot_type,
                row.shot_from || '',
                row.shot_to || '',
                row.shot_result || 'hit',
                row.confidence,
                row.created_at
            ]);

            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');

            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `tt-labels-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            URL.revokeObjectURL(url);

            showToast(`${data.length} Labels exportiert!`, 'success');
        }

        async function exportJSON() {
            showToast('Exportiere JSON...', 'info');

            // Get all labeled data with video info
            const { data, error } = await supabase
                .from('video_labels')
                .select(`
                    id,
                    timestamp_start,
                    timestamp_end,
                    shot_type,
                    shot_from,
                    shot_to,
                    shot_result,
                    confidence,
                    created_at,
                    video:video_analyses(
                        id,
                        title,
                        video_url,
                        video_type,
                        exercise_id,
                        exercise:exercises(name, category)
                    )
                `)
                .order('created_at');

            if (error) {
                showToast('Export fehlgeschlagen: ' + error.message, 'error');
                return;
            }

            if (!data || data.length === 0) {
                showToast('Keine Daten zum Exportieren', 'warning');
                return;
            }

            // Group by video for better structure
            const videoMap = {};
            data.forEach(label => {
                const videoId = label.video?.id;
                if (!videoId) return;

                if (!videoMap[videoId]) {
                    videoMap[videoId] = {
                        video_id: videoId,
                        title: label.video.title,
                        video_url: label.video.video_url,
                        video_type: label.video.video_type,
                        exercise: label.video.exercise?.name || null,
                        exercise_category: label.video.exercise?.category || null,
                        labels: []
                    };
                }

                videoMap[videoId].labels.push({
                    label_id: label.id,
                    timestamp_start: label.timestamp_start,
                    timestamp_end: label.timestamp_end,
                    duration_ms: Math.round((label.timestamp_end - label.timestamp_start) * 1000),
                    shot_type: label.shot_type,
                    shot_from: label.shot_from,
                    shot_to: label.shot_to,
                    shot_result: label.shot_result || 'hit',
                    confidence: label.confidence
                });
            });

            const exportData = {
                export_date: new Date().toISOString(),
                total_labels: data.length,
                total_videos: Object.keys(videoMap).length,
                videos: Object.values(videoMap)
            };

            // Download
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `tt-labels-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showToast(`${data.length} Labels in ${Object.keys(videoMap).length} Videos exportiert!`, 'success');
        }

        async function exportMLTraining() {
            showToast('Erstelle ML-Training Export...', 'info');

            // Get all labeled data with video info and AI analysis data
            const { data: labels, error } = await supabase
                .from('video_labels')
                .select(`
                    id,
                    timestamp_start,
                    timestamp_end,
                    shot_type,
                    shot_from,
                    shot_to,
                    shot_result,
                    confidence,
                    video:video_analyses(
                        id,
                        title,
                        video_url,
                        video_type
                    )
                `)
                .order('created_at');

            if (error) {
                showToast('Export fehlgeschlagen: ' + error.message, 'error');
                return;
            }

            if (!labels || labels.length === 0) {
                showToast('Keine Daten zum Exportieren', 'warning');
                return;
            }

            // Load table calibrations and ball tracks
            const videoIds = [...new Set(labels.map(l => l.video?.id).filter(Boolean))];
            const calibrations = {};
            const ballTracks = {};

            for (const videoId of videoIds) {
                // Table calibration
                const { data: calData } = await supabase
                    .from('video_ai_analyses')
                    .select('results')
                    .eq('video_id', videoId)
                    .eq('analysis_type', 'table_calibration')
                    .eq('status', 'completed')
                    .order('created_at', { ascending: false })
                    .limit(1)
                    .maybeSingle();

                if (calData?.results?.corners) {
                    calibrations[videoId] = calData.results.corners;
                }

                // Ball track data
                const { data: tbData } = await supabase
                    .from('video_ai_analyses')
                    .select('id')
                    .eq('video_id', videoId)
                    .eq('analysis_type', 'table_ball_detection')
                    .eq('status', 'completed')
                    .order('created_at', { ascending: false })
                    .limit(1)
                    .maybeSingle();

                if (tbData) {
                    const { data: frames } = await supabase
                        .from('video_ai_frames')
                        .select('timestamp_seconds, ball_x, ball_y, ball_confidence')
                        .eq('analysis_id', tbData.id)
                        .not('ball_x', 'is', null)
                        .order('timestamp_seconds');

                    if (frames && frames.length > 0) {
                        ballTracks[videoId] = frames.map(f => ({
                            time: f.timestamp_seconds,
                            x: f.ball_x,
                            y: f.ball_y,
                            conf: f.ball_confidence
                        }));
                    }
                }
            }

            // Build ML training export
            const exportData = {
                format: 'tt-champions-ml-training',
                version: '1.0',
                export_date: new Date().toISOString(),
                description: 'Tischtennis ML-Training Daten fuer RF-DETR / Custom Model',
                stats: {
                    total_labels: labels.length,
                    total_videos: videoIds.length,
                    videos_with_calibration: Object.keys(calibrations).length,
                    videos_with_ball_track: Object.keys(ballTracks).length
                },
                // Instructions for using this data
                instructions: {
                    step1: 'Videos herunterladen (video_url)',
                    step2: 'Frames extrahieren mit ffmpeg: ffmpeg -i video.mp4 -vf fps=5 frames/%04d.jpg',
                    step3: 'Bounding Boxes in Roboflow zeichnen (ball, racket, table)',
                    step4: 'Timestamps nutzen um relevante Frames zu finden',
                    step5: 'Ball-Track Daten als Pre-Labels verwenden'
                },
                videos: videoIds.map(videoId => {
                    const videoLabels = labels.filter(l => l.video?.id === videoId);
                    const firstLabel = videoLabels[0];
                    return {
                        video_id: videoId,
                        title: firstLabel?.video?.title || '',
                        video_url: firstLabel?.video?.video_url || '',
                        video_type: firstLabel?.video?.video_type || '',
                        table_calibration: calibrations[videoId] || null,
                        ball_track: ballTracks[videoId] || [],
                        shot_labels: videoLabels.map(l => ({
                            timestamp_start: l.timestamp_start,
                            timestamp_end: l.timestamp_end,
                            shot_type: l.shot_type,
                            shot_from: l.shot_from,
                            shot_to: l.shot_to,
                            shot_result: l.shot_result || 'hit',
                            confidence: l.confidence
                        }))
                    };
                })
            };

            // Download
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `tt-ml-training-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            const calCount = Object.keys(calibrations).length;
            const ballCount = Object.keys(ballTracks).length;
            showToast(
                `ML-Export: ${labels.length} Labels, ${videoIds.length} Videos, ${calCount} Kalibrierungen, ${ballCount} Ball-Tracks`,
                'success'
            );
        }

        async function loadExercises() {
            const { data: exercises } = await supabase
                .from('exercises')
                .select('id, name, category, difficulty')
                .order('category')
                .order('name');

            exercisesList = exercises || [];

            // Populate dropdown
            const select = document.getElementById('exercise-select');
            if (select && exercisesList.length > 0) {
                // Group by category
                const byCategory = {};
                exercisesList.forEach(ex => {
                    const cat = ex.category || 'Sonstiges';
                    if (!byCategory[cat]) byCategory[cat] = [];
                    byCategory[cat].push(ex);
                });

                select.innerHTML = '<option value="">-- √úbung ausw√§hlen --</option>';
                Object.entries(byCategory).forEach(([cat, exercises]) => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = cat;
                    exercises.forEach(ex => {
                        const opt = document.createElement('option');
                        opt.value = ex.id;
                        opt.textContent = ex.name;
                        optgroup.appendChild(opt);
                    });
                    select.appendChild(optgroup);
                });
            }
        }

        async function loadPendingVideos() {
            const feedContainer = document.getElementById('video-feed');

            // Get ALL videos with allow_ai_training = true that aren't labeled yet
            // Includes: player uploads (with/without club), coach-assigned videos
            const { data: videos, error } = await supabase
                .from('video_analyses')
                .select(`
                    *,
                    uploader:profiles!uploaded_by(first_name, last_name),
                    comments:video_comments(count),
                    exercise:exercises(id, name, category)
                `)
                .eq('allow_ai_training', true)
                .eq('ai_ready', false)
                .order('created_at', { ascending: true });

            if (error) {
                console.error('Error loading videos:', error);
                feedContainer.innerHTML = '<p class="col-span-full text-center text-red-500 py-8">Fehler beim Laden: ' + error.message + '</p>';
                return;
            }

            const pendingVideos = videos || [];
            document.getElementById('pending-count').textContent = pendingVideos.length;

            if (pendingVideos.length === 0) {
                feedContainer.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <i class="fas fa-check-circle text-5xl text-green-400 mb-4"></i>
                        <p class="text-gray-600 font-medium">Alle Videos sind gelabelt!</p>
                        <p class="text-gray-500 text-sm mt-1">Es gibt keine Videos zum Labeln.</p>
                    </div>
                `;
                return;
            }

            feedContainer.innerHTML = pendingVideos.map(video => {
                const hasComments = video.comments?.[0]?.count > 0;
                return `
                <div class="video-card bg-white rounded-xl shadow-md overflow-hidden hover:shadow-lg transition-shadow cursor-pointer"
                     data-video-id="${video.id}">
                    <div class="aspect-video bg-gray-200 relative">
                        ${video.thumbnail_url
                            ? `<img src="${video.thumbnail_url}" class="w-full h-full object-cover">`
                            : `<div class="w-full h-full flex items-center justify-center text-gray-400"><i class="fas fa-video text-4xl"></i></div>`
                        }
                        ${hasComments ? `<span class="absolute top-2 right-2 bg-blue-500 text-white text-xs px-2 py-1 rounded-full"><i class="fas fa-comment mr-1"></i>Kommentare</span>` : ''}
                    </div>
                    <div class="p-3">
                        <p class="font-medium text-sm truncate">${video.title || 'Ohne Titel'}</p>
                        <p class="text-xs text-gray-500 mt-1">
                            von ${video.uploader?.first_name || 'Unbekannt'} ${video.uploader?.last_name?.charAt(0) || ''}.
                        </p>
                        <p class="text-xs text-gray-400 mt-1">
                            ${new Date(video.created_at).toLocaleDateString('de-DE')}
                        </p>
                    </div>
                </div>
            `}).join('');

            // Add click handlers
            feedContainer.querySelectorAll('.video-card').forEach(card => {
                card.addEventListener('click', () => {
                    const videoId = card.dataset.videoId;
                    const video = pendingVideos.find(v => v.id === videoId);
                    if (video) openLabelingInterface(video);
                });
            });
        }

        async function openLabelingInterface(video) {
            currentVideo = video;
            currentShots = [];
            aiSuggestions = [];
            aiFormattedFrames = null;
            aiDetectedPlayers = [];
            selectedVideoType = video.video_type || null;
            selectedExerciseId = video.exercise_id || null;

            document.getElementById('video-feed').classList.add('hidden');
            document.getElementById('labeling-interface').classList.remove('hidden');

            // Set video
            videoPlayer = document.getElementById('label-video');
            videoPlayer.src = video.video_url;
            document.getElementById('video-title').textContent = video.title || 'Ohne Titel';

            // Reset and set video type buttons
            document.querySelectorAll('.vtype-btn').forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'border-blue-600');
                btn.classList.add('bg-white', 'border-gray-300');
            });
            if (selectedVideoType) {
                const vtypeBtn = document.querySelector(`.vtype-btn[data-vtype="${selectedVideoType}"]`);
                if (vtypeBtn) {
                    vtypeBtn.classList.remove('bg-white', 'border-gray-300');
                    vtypeBtn.classList.add('bg-blue-600', 'text-white', 'border-blue-600');
                }
            }

            // Show/hide exercise selection
            const exerciseSelection = document.getElementById('exercise-selection');
            exerciseSelection.classList.toggle('hidden', selectedVideoType !== 'exercise');

            // Set exercise dropdown
            if (selectedExerciseId) {
                document.getElementById('exercise-select').value = selectedExerciseId;
            } else {
                document.getElementById('exercise-select').value = '';
            }

            // Show upload info if exercise was set
            const uploadInfo = document.getElementById('upload-info');
            const uploadExerciseName = document.getElementById('upload-exercise-name');
            if (video.exercise_id && video.exercise) {
                uploadInfo.classList.remove('hidden');
                uploadExerciseName.textContent = `üìã ${video.exercise.name}`;
            } else if (video.video_type) {
                uploadInfo.classList.remove('hidden');
                uploadExerciseName.textContent = `${videoTypeLabels[video.video_type] || video.video_type}`;
            } else {
                uploadInfo.classList.add('hidden');
            }

            // Load existing labels for this video
            const { data: existingLabels } = await supabase
                .from('video_labels')
                .select('*')
                .eq('video_id', video.id)
                .order('timestamp_start');

            if (existingLabels?.length > 0) {
                currentShots = existingLabels.map(label => ({
                    id: label.id,
                    startTime: label.timestamp_start,
                    endTime: label.timestamp_end,
                    shotType: label.shot_type,
                    shotFrom: label.shot_from,
                    shotTo: label.shot_to,
                    shotResult: label.shot_result || 'hit',
                    saved: true
                }));
            }

            // Load coach comments using RPC (SECURITY DEFINER bypasses RLS)
            const { data: comments } = await supabase.rpc('get_video_comments', {
                p_video_id: video.id
            });

            const commentsContainer = document.getElementById('coach-comments');
            if (comments?.length > 0) {
                commentsContainer.innerHTML = comments.map(c => {
                    const userName = c.user_name || 'Unbekannt';
                    const isCoach = c.user_role === 'coach' || c.user_role === 'head_coach';

                    // Check if comment has a drawing (embedded in content as markdown)
                    const drawingMatch = c.content?.match(/\[Zeichnung\]\((https?:\/\/[^\)]+)\)/);
                    const hasDrawing = !!drawingMatch;
                    const drawingUrl = drawingMatch?.[1];

                    return `
                    <div class="bg-gray-50 rounded-lg p-2 text-sm">
                        <div class="flex items-center gap-2 mb-1">
                            <span class="font-medium ${isCoach ? 'text-indigo-600' : 'text-gray-700'}">${userName}</span>
                            ${isCoach ? '<span class="text-xs bg-indigo-100 text-indigo-700 px-1.5 py-0.5 rounded">Coach</span>' : ''}
                            ${c.timestamp_seconds !== null
                                ? `<button class="comment-timestamp text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded" data-time="${c.timestamp_seconds}">${formatTime(c.timestamp_seconds)}</button>`
                                : ''
                            }
                        </div>
                        ${hasDrawing && drawingUrl
                            ? `<img src="${drawingUrl}" class="max-w-full rounded border border-gray-200 mb-2 cursor-pointer hover:opacity-90" style="max-height: 150px;" onclick="window.open('${drawingUrl}', '_blank')">`
                            : `<p class="text-gray-700">${c.content}</p>`
                        }
                    </div>
                `}).join('');

                // Add click handlers for timestamps
                commentsContainer.querySelectorAll('.comment-timestamp').forEach(btn => {
                    btn.addEventListener('click', () => {
                        videoPlayer.currentTime = parseFloat(btn.dataset.time);
                    });
                });
            } else {
                commentsContainer.innerHTML = '<p class="text-gray-500 text-sm text-center">Keine Kommentare</p>';
            }

            // Video time update
            videoPlayer.addEventListener('loadedmetadata', () => {
                document.getElementById('total-time').textContent = formatTime(videoPlayer.duration);
                document.getElementById('timeline-end').textContent = formatTime(videoPlayer.duration);
            });

            videoPlayer.addEventListener('timeupdate', () => {
                document.getElementById('current-time').textContent = formatTime(videoPlayer.currentTime);
                updateTimelineMarker();
                drawOverlay();
            });
            videoPlayer.addEventListener('seeked', drawOverlay);

            // Canvas-Overlay initialisieren
            overlayCanvas = document.getElementById('video-overlay');
            overlayCtx = overlayCanvas.getContext('2d');
            videoPlayer.addEventListener('loadedmetadata', async () => {
                overlayCanvas.width = videoPlayer.videoWidth;
                overlayCanvas.height = videoPlayer.videoHeight;

                // Gespeicherte Tisch/Ball-Daten aus DB laden
                try {
                    const saved = await loadTableBallResults(supabase, video.id);
                    if (saved) {
                        if (saved.table) {
                            aiTableBox = saved.table;
                            console.log('[AI] Tisch aus DB geladen:', aiTableBox.color);
                        }
                        if (saved.ballTrack && saved.ballTrack.length > 0) {
                            aiBallTrack = saved.ballTrack;
                            console.log('[AI] Ball-Track aus DB geladen:', aiBallTrack.length, 'Positionen');
                        }
                        // Info-Bereich aktualisieren falls Daten vorhanden
                        if (aiTableBox || aiBallTrack.length > 0) {
                            const infoDiv = document.getElementById('ai-table-ball-info');
                            const tableInfo = document.getElementById('ai-table-info');
                            const ballInfo = document.getElementById('ai-ball-info');
                            infoDiv.classList.remove('hidden');
                            if (aiTableBox) {
                                const colorLabel = aiTableBox.color === 'blue' ? 'blauer' : aiTableBox.color === 'green' ? 'gr√ºner' : '';
                                tableInfo.innerHTML = `<i class="fas fa-database text-blue-400"></i> <strong>${colorLabel} Tisch</strong> (aus gespeicherter Analyse)`;
                            }
                            if (aiBallTrack.length > 0) {
                                const frames = new Set(aiBallTrack.map(b => Math.round(b.time * 10))).size;
                                ballInfo.innerHTML = `<i class="fas fa-database text-blue-400"></i> <strong>Ball-Track</strong> ${frames} Frames (aus gespeicherter Analyse)`;
                            }
                        }
                    }
                } catch (e) {
                    console.warn('[AI] Could not load saved table/ball data:', e);
                }

                // Gespeicherte Tisch-Kalibrierung laden
                try {
                    const corners = await loadTableCalibration(supabase, video.id);
                    if (corners && corners.length === 4) {
                        savedTableCorners = corners;
                        console.log('[AI] Tisch-Kalibrierung aus DB geladen');
                        // Tisch-Overlay automatisch aktivieren
                        showTable = true;
                        const tableBtn = document.getElementById('toggle-table');
                        tableBtn.dataset.active = 'true';
                        tableBtn.classList.remove('text-gray-400', 'border-gray-600');
                        tableBtn.classList.add('bg-white', 'text-gray-800', 'border-white');
                        // Kalibrieren-Button Text √§ndern
                        document.getElementById('btn-calibrate-table').innerHTML =
                            '<i class="fas fa-crosshairs mr-1"></i>Neu kalibrieren';
                        drawOverlay();
                    }
                } catch (e) {
                    console.warn('[AI] Could not load table calibration:', e);
                }
            });

            renderShotsList();
            renderTimeline();

            // KI-Vorschl√§ge UI zur√ºcksetzen
            document.getElementById('ai-suggestions').classList.add('hidden');
            document.getElementById('ai-progress').classList.add('hidden');
            document.getElementById('ai-players').classList.add('hidden');
        }

        function setupEventListeners() {
            // Back button
            document.getElementById('back-to-feed').addEventListener('click', () => {
                document.getElementById('labeling-interface').classList.add('hidden');
                document.getElementById('video-feed').classList.remove('hidden');
                if (aiAbortController) aiAbortController.abort();
                currentVideo = null;
                currentShots = [];
                aiSuggestions = [];
                aiFormattedFrames = null;
                aiDetectedPlayers = [];
                aiTableBox = null;
                aiBallTrack = [];
                savedTableCorners = null;
                calibrationCorners = [];
                calibrationMode = false;
                showSkeleton = false;
                showTable = false;
                showBall = false;
                selectedVideoType = null;
                selectedExerciseId = null;
            });

            // Export buttons
            document.getElementById('export-csv-btn').addEventListener('click', exportCSV);
            document.getElementById('export-json-btn').addEventListener('click', exportJSON);
            document.getElementById('export-roboflow-btn').addEventListener('click', exportMLTraining);

            // Video type buttons
            document.querySelectorAll('.vtype-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.vtype-btn').forEach(b => {
                        b.classList.remove('bg-blue-600', 'text-white', 'border-blue-600');
                        b.classList.add('bg-white', 'border-gray-300');
                    });
                    btn.classList.remove('bg-white', 'border-gray-300');
                    btn.classList.add('bg-blue-600', 'text-white', 'border-blue-600');
                    selectedVideoType = btn.dataset.vtype;

                    // Show/hide exercise selection
                    const exerciseSelection = document.getElementById('exercise-selection');
                    exerciseSelection.classList.toggle('hidden', selectedVideoType !== 'exercise');

                    // Reset exercise if not exercise type
                    if (selectedVideoType !== 'exercise') {
                        selectedExerciseId = null;
                        document.getElementById('exercise-select').value = '';
                    }
                });
            });

            // Exercise dropdown
            document.getElementById('exercise-select').addEventListener('change', (e) => {
                selectedExerciseId = e.target.value || null;
            });

            // KI-Analyse Buttons
            document.getElementById('ai-analyze-btn').addEventListener('click', runAIAnalysis);

            // Overlay-Toggle-Buttons
            document.querySelectorAll('.overlay-toggle').forEach(btn => {
                btn.addEventListener('click', () => {
                    const isActive = btn.dataset.active === 'true';
                    btn.dataset.active = isActive ? 'false' : 'true';
                    if (isActive) {
                        btn.classList.remove('bg-white', 'text-gray-800', 'border-white');
                        btn.classList.add('text-gray-400', 'border-gray-600');
                    } else {
                        btn.classList.remove('text-gray-400', 'border-gray-600');
                        btn.classList.add('bg-white', 'text-gray-800', 'border-white');
                    }
                });
            });
            document.getElementById('toggle-skeleton').addEventListener('click', () => {
                showSkeleton = !showSkeleton;
                drawOverlay();
            });
            document.getElementById('toggle-table').addEventListener('click', () => {
                showTable = !showTable;
                drawOverlay();
            });
            document.getElementById('toggle-ball').addEventListener('click', () => {
                showBall = !showBall;
                drawOverlay();
            });

            // Tisch-Kalibrierung
            document.getElementById('btn-calibrate-table').addEventListener('click', startCalibration);
            document.getElementById('btn-calibration-cancel').addEventListener('click', cancelCalibration);
            document.getElementById('btn-calibration-undo').addEventListener('click', undoCalibrationCorner);
            document.getElementById('video-overlay').addEventListener('click', handleCalibrationClick);

            document.getElementById('ai-table-ball-btn').addEventListener('click', runTableBallDetection);
            document.getElementById('ai-cancel-btn').addEventListener('click', () => {
                if (aiAbortController) aiAbortController.abort();
            });
            document.getElementById('ai-accept-all-btn').addEventListener('click', acceptAllAISuggestions);
            document.getElementById('ai-clear-btn').addEventListener('click', () => {
                aiSuggestions = [];
                renderAISuggestions();
                renderTimeline();
                showToast('KI-Vorschl√§ge verworfen', 'info');
            });
            document.getElementById('ai-reclassify-btn').addEventListener('click', () => {
                reclassifyWithPlayers();
            });

            // "Von" position buttons
            document.querySelectorAll('.from-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.from-btn').forEach(b => {
                        b.classList.remove('bg-indigo-600', 'bg-purple-600', 'text-white');
                        b.classList.add('bg-white');
                    });
                    btn.classList.remove('bg-white');
                    const color = btn.dataset.from === 'rh' ? 'bg-purple-600' : 'bg-indigo-600';
                    btn.classList.add(color, 'text-white');
                });
            });

            // "Nach" position buttons
            document.querySelectorAll('.to-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.to-btn').forEach(b => {
                        b.classList.remove('bg-indigo-600', 'bg-purple-600', 'text-white');
                        b.classList.add('bg-white');
                    });
                    btn.classList.remove('bg-white');
                    const color = btn.dataset.to === 'rh' ? 'bg-purple-600' : 'bg-indigo-600';
                    btn.classList.add(color, 'text-white');
                });
            });

            // Shot type buttons
            document.querySelectorAll('.shot-type-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.shot-type-btn').forEach(b => {
                        b.classList.remove('bg-indigo-600', 'bg-purple-600', 'text-white', 'border-indigo-600', 'border-purple-600');
                        b.classList.add('border-gray-300');
                    });
                    const isBackhand = btn.dataset.type.startsWith('backhand');
                    btn.classList.remove('border-gray-300');
                    btn.classList.add(isBackhand ? 'bg-purple-600' : 'bg-indigo-600', 'text-white');
                });
            });

            // Result buttons
            document.querySelectorAll('.result-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.result-btn').forEach(b => {
                        b.classList.remove('bg-green-600', 'bg-orange-500', 'bg-red-500', 'bg-gray-500', 'text-white');
                        b.classList.add('bg-white');
                    });
                    btn.classList.remove('bg-white');
                    const colors = {
                        'hit': 'bg-green-600',
                        'net': 'bg-orange-500',
                        'out': 'bg-red-500',
                        'miss': 'bg-gray-500'
                    };
                    btn.classList.add(colors[btn.dataset.result], 'text-white');
                });
            });

            // Set current time buttons (with milliseconds)
            document.getElementById('set-start-current').addEventListener('click', () => {
                if (videoPlayer) {
                    const time = videoPlayer.currentTime;
                    document.getElementById('shot-start-min').value = Math.floor(time / 60);
                    document.getElementById('shot-start-sec').value = Math.floor(time % 60);
                    document.getElementById('shot-start-ms').value = Math.floor((time % 1) * 1000);
                }
            });

            document.getElementById('set-end-current').addEventListener('click', () => {
                if (videoPlayer) {
                    const time = videoPlayer.currentTime;
                    document.getElementById('shot-end-min').value = Math.floor(time / 60);
                    document.getElementById('shot-end-sec').value = Math.floor(time % 60);
                    document.getElementById('shot-end-ms').value = Math.floor((time % 1) * 1000);
                }
            });

            // Add shot button
            document.getElementById('add-shot-btn').addEventListener('click', addShot);

            // Verify button
            document.getElementById('verify-btn').addEventListener('click', verifyAndSave);

            // Skip button
            document.getElementById('skip-btn').addEventListener('click', skipVideo);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (!currentVideo) return;
                if (e.target.tagName === 'INPUT') return;

                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        videoPlayer.paused ? videoPlayer.play() : videoPlayer.pause();
                        break;
                    case 's':
                    case 'S':
                        document.getElementById('set-start-current').click();
                        break;
                    case 'e':
                    case 'E':
                        document.getElementById('set-end-current').click();
                        break;
                    case 'Enter':
                        addShot();
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                        const shotTypes = document.querySelectorAll('.shot-type-btn');
                        const index = parseInt(e.key) - 1;
                        if (shotTypes[index]) shotTypes[index].click();
                        break;
                }
            });
        }

        function addShot() {
            // Get values
            const startMin = parseInt(document.getElementById('shot-start-min').value) || 0;
            const startSec = parseInt(document.getElementById('shot-start-sec').value) || 0;
            const startMs = parseInt(document.getElementById('shot-start-ms').value) || 0;
            const endMin = parseInt(document.getElementById('shot-end-min').value) || 0;
            const endSec = parseInt(document.getElementById('shot-end-sec').value) || 0;
            const endMs = parseInt(document.getElementById('shot-end-ms').value) || 0;

            // Zeit in Sekunden mit Millisekunden-Pr√§zision
            const startTime = startMin * 60 + startSec + (startMs / 1000);
            const endTime = endMin * 60 + endSec + (endMs / 1000);

            // Get "Von" position
            const fromBtn = document.querySelector('.from-btn.bg-indigo-600, .from-btn.bg-purple-600');
            const shotFrom = fromBtn?.dataset.from || null;

            // Get "Nach" position
            const toBtn = document.querySelector('.to-btn.bg-indigo-600, .to-btn.bg-purple-600');
            const shotTo = toBtn?.dataset.to || null;

            const shotTypeBtn = document.querySelector('.shot-type-btn.bg-indigo-600, .shot-type-btn.bg-purple-600');
            const shotType = shotTypeBtn?.dataset.type || null;

            // Get result
            const resultBtn = document.querySelector('.result-btn.bg-green-600, .result-btn.bg-orange-500, .result-btn.bg-red-500, .result-btn.bg-gray-500');
            const shotResult = resultBtn?.dataset.result || 'hit'; // Default: hit

            // Validation
            if (!shotType) {
                showToast('Bitte Schlagtyp ausw√§hlen', 'warning');
                return;
            }

            if (endTime <= startTime) {
                showToast('Endzeit muss nach Startzeit liegen', 'warning');
                return;
            }

            // Wenn wir einen KI-Vorschlag bearbeiten, als akzeptiert markieren
            const isAIEdit = editingAISuggestionIndex !== null;
            const aiIdx = editingAISuggestionIndex;

            // Add shot
            currentShots.push({
                id: Date.now().toString(),
                startTime,
                endTime,
                shotType,
                shotFrom,
                shotTo,
                shotResult,
                saved: false,
                aiGenerated: isAIEdit,
                aiOriginalType: isAIEdit ? aiSuggestions[aiIdx]?.shotType : undefined,
                aiCorrected: isAIEdit,
                playerNum: isAIEdit ? aiSuggestions[aiIdx]?.playerNum : undefined,
                playerSide: isAIEdit ? aiSuggestions[aiIdx]?.playerSide : undefined
            });

            // KI-Vorschlag als akzeptiert markieren
            if (isAIEdit && aiSuggestions[aiIdx]) {
                aiSuggestions[aiIdx].accepted = true;
                renderAISuggestions();
            }
            resetEditMode();

            // Reset form
            document.querySelectorAll('.from-btn, .to-btn, .shot-type-btn').forEach(btn => {
                btn.classList.remove('bg-indigo-600', 'bg-purple-600', 'text-white', 'border-indigo-600', 'border-purple-600');
                btn.classList.add('bg-white', 'border-gray-300');
            });

            // Reset result to default (hit)
            document.querySelectorAll('.result-btn').forEach(btn => {
                btn.classList.remove('bg-green-600', 'bg-orange-500', 'bg-red-500', 'bg-gray-500', 'text-white');
                btn.classList.add('bg-white');
            });
            document.querySelector('.result-btn[data-result="hit"]').classList.remove('bg-white');
            document.querySelector('.result-btn[data-result="hit"]').classList.add('bg-green-600', 'text-white');

            renderShotsList();
            renderTimeline();
            showToast('Schlag hinzugef√ºgt', 'success');
        }

        function renderShotsList() {
            const container = document.getElementById('shots-list');
            document.getElementById('shot-count').textContent = currentShots.length;

            if (currentShots.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">Noch keine Schl√§ge markiert</p>';
                return;
            }

            const posLabels = { vh: 'VH', mitte: 'M', rh: 'RH' };
            const resultLabels = { hit: '‚úì', net: 'ü•Ö', out: '‚Üó', miss: '‚úó' };
            const resultColors = { hit: 'text-green-600', net: 'text-orange-500', out: 'text-red-500', miss: 'text-gray-500' };
            container.innerHTML = currentShots.map((shot, index) => {
                const aiTag = shot.aiGenerated
                    ? (shot.aiCorrected
                        ? '<span class="text-xs bg-yellow-100 text-yellow-700 px-1 rounded" title="KI-erkannt, korrigiert">KI‚úé</span>'
                        : '<span class="text-xs bg-cyan-100 text-cyan-700 px-1 rounded" title="KI-erkannt">KI</span>')
                    : '';
                const playerTag = shot.playerNum
                    ? `<span class="text-xs px-1 rounded ${shot.playerSide === 'left' ? 'bg-blue-100 text-blue-700' : 'bg-orange-100 text-orange-700'}">S${shot.playerNum}</span>`
                    : '';
                return `
                <div class="shot-item flex items-center justify-between p-2 ${shot.aiGenerated ? 'bg-cyan-50' : 'bg-gray-50'} rounded-lg group">
                    <div class="flex items-center gap-2 flex-wrap">
                        ${playerTag}
                        <span class="text-xs font-mono text-gray-500">${formatTime(shot.startTime)}-${formatTime(shot.endTime)}</span>
                        <span class="text-sm font-medium ${shot.shotType.startsWith('backhand') ? 'text-purple-600' : 'text-indigo-600'}">
                            ${shotTypeLabels[shot.shotType] || shot.shotType}
                        </span>
                        ${aiTag}
                        ${shot.shotFrom || shot.shotTo ? `<span class="text-xs text-gray-400">(${posLabels[shot.shotFrom] || '?'} ‚Üí ${posLabels[shot.shotTo] || '?'})</span>` : ''}
                        <span class="${resultColors[shot.shotResult] || 'text-green-600'}" title="${shot.shotResult}">${resultLabels[shot.shotResult] || '‚úì'}</span>
                    </div>
                    <button class="delete-shot opacity-0 group-hover:opacity-100 text-red-500 hover:text-red-700 p-1 transition-opacity" data-index="${index}">
                        <i class="fas fa-trash text-xs"></i>
                    </button>
                </div>
            `}).join('');

            // Delete handlers
            container.querySelectorAll('.delete-shot').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    currentShots.splice(index, 1);
                    renderShotsList();
                    renderTimeline();
                });
            });
        }

        function renderTimeline() {
            const timeline = document.getElementById('timeline');
            const duration = videoPlayer?.duration || 1;

            // Clear existing markers
            timeline.querySelectorAll('.shot-marker').forEach(m => m.remove());

            // Add shot markers
            currentShots.forEach(shot => {
                const startPercent = (shot.startTime / duration) * 100;
                const widthPercent = ((shot.endTime - shot.startTime) / duration) * 100;
                const isBackhand = shot.shotType.startsWith('backhand');

                const marker = document.createElement('div');
                marker.className = `shot-marker absolute top-0 h-full ${isBackhand ? 'bg-purple-500' : 'bg-indigo-500'} opacity-50 hover:opacity-75 cursor-pointer`;
                marker.style.left = `${startPercent}%`;
                marker.style.width = `${widthPercent}%`;
                marker.title = `${shotTypeLabels[shot.shotType]}: ${formatTime(shot.startTime)} - ${formatTime(shot.endTime)}`;

                marker.addEventListener('click', () => {
                    videoPlayer.currentTime = shot.startTime;
                });

                timeline.appendChild(marker);
            });

            // KI-Vorschl√§ge als hellere Marker anzeigen (noch nicht √ºbernommen)
            aiSuggestions.filter(s => !s.accepted).forEach(sug => {
                const displayType = sug.correctedType || sug.shotType;
                const startPercent = (sug.startTime / duration) * 100;
                const widthPercent = Math.max(0.5, ((sug.endTime - sug.startTime) / duration) * 100);
                const isBackhand = displayType.startsWith('backhand');

                const marker = document.createElement('div');
                marker.className = `shot-marker absolute top-0 h-full ${isBackhand ? 'bg-purple-300' : 'bg-cyan-300'} opacity-40 hover:opacity-70 cursor-pointer border-t-2 ${isBackhand ? 'border-purple-500' : 'border-cyan-500'}`;
                marker.style.left = `${startPercent}%`;
                marker.style.width = `${widthPercent}%`;
                marker.title = `KI: ${shotTypeLabels[displayType] || displayType} (${Math.round(sug.confidence * 100)}%)`;

                marker.addEventListener('click', () => {
                    videoPlayer.currentTime = sug.startTime;
                });

                timeline.appendChild(marker);
            });
        }

        function updateTimelineMarker() {
            // Could add a current position marker here
        }

        async function verifyAndSave() {
            if (currentShots.length === 0) {
                showToast('Bitte mindestens einen Schlag markieren', 'warning');
                return;
            }

            try {
                // Save new shots to video_labels
                const newShots = currentShots.filter(s => !s.saved);
                if (newShots.length > 0) {
                    const labelsToInsert = newShots.map(shot => {
                        // Konfidenz: KI-korrigierte Schl√§ge = 'certain' (menschlich √ºberpr√ºft),
                        // KI-unver√§ndert = 'probable', manuell = 'certain'
                        let confidence = 'certain';
                        if (shot.aiGenerated && !shot.aiCorrected) confidence = 'probable';

                        const label = {
                            video_id: currentVideo.id,
                            labeled_by: currentUser.id,
                            club_id: currentVideo.club_id,
                            timestamp_start: shot.startTime,
                            timestamp_end: shot.endTime,
                            event_type: 'shot',
                            shot_type: shot.shotType,
                            shot_from: shot.shotFrom,
                            shot_to: shot.shotTo,
                            shot_result: shot.shotResult,
                            confidence,
                            is_verified: true,
                            verified_by: currentUser.id
                        };

                        // KI-Metadaten als Notiz speichern (f√ºr sp√§teres Retraining)
                        if (shot.aiGenerated) {
                            label.notes = shot.aiCorrected
                                ? `AI-detected: ${shot.aiOriginalType}, corrected to: ${shot.shotType}`
                                : `AI-detected: ${shot.shotType}, confirmed`;
                        }

                        return label;
                    });

                    const { error: insertError } = await supabase
                        .from('video_labels')
                        .insert(labelsToInsert);

                    if (insertError) throw insertError;
                }

                // Mark video as ai_ready and save video type/exercise
                const updateData = { ai_ready: true };
                if (selectedVideoType) updateData.video_type = selectedVideoType;
                if (selectedExerciseId) updateData.exercise_id = selectedExerciseId;

                const { error: updateError } = await supabase
                    .from('video_analyses')
                    .update(updateData)
                    .eq('id', currentVideo.id);

                if (updateError) throw updateError;

                showToast('Video verifiziert und gespeichert!', 'success');

                // Update stats
                loadStats();

                // Go back to feed
                document.getElementById('back-to-feed').click();
                loadPendingVideos();

            } catch (error) {
                console.error('Error saving:', error);
                showToast('Fehler beim Speichern', 'error');
            }
        }

        async function skipVideo() {
            try {
                // Mark as ai_ready but add metadata that it's unsuitable
                const { error } = await supabase
                    .from('video_analyses')
                    .update({ ai_ready: true })
                    .eq('id', currentVideo.id);

                // Also add to ml_metadata as unsuitable
                await supabase.from('video_ml_metadata').upsert({
                    video_id: currentVideo.id,
                    suitable_for_training: false,
                    exclusion_reason: 'Manually marked as unsuitable'
                });

                if (error) throw error;

                showToast('Video √ºbersprungen', 'info');
                document.getElementById('back-to-feed').click();
                loadPendingVideos();

            } catch (error) {
                console.error('Error skipping:', error);
                showToast('Fehler beim √úberspringen', 'error');
            }
        }

        // ===== KI-Voranalyse =====

        // Berechnet stabile Spieler-Positionen aus den Pose-Daten.
        // Nutzt die durchschnittliche X-Position der Schultern pro Spieler-Index
        // und ordnet Spieler konsistent nach links/rechts im Bild zu.
        function identifyPlayers(formattedFrames) {
            const maxPlayers = Math.max(...formattedFrames.map(f => f.poses?.length || 0));
            if (maxPlayers === 0) return [];

            // Durchschnittliche X-Position pro playerIdx berechnen
            const playerStats = [];
            for (let pIdx = 0; pIdx < maxPlayers; pIdx++) {
                let totalX = 0;
                let count = 0;

                for (const frame of formattedFrames) {
                    if (!frame.poses || frame.poses.length <= pIdx) continue;
                    const lm = frame.poses[pIdx].landmarks;
                    if (!lm) continue;

                    // Schulter-Mittelpunkt als stabile Position
                    const ls = lm[11]; // LEFT_SHOULDER
                    const rs = lm[12]; // RIGHT_SHOULDER
                    if (ls && rs && (ls.visibility || 0) > 0.3 && (rs.visibility || 0) > 0.3) {
                        totalX += (ls.x + rs.x) / 2;
                        count++;
                    }
                }

                if (count > 0) {
                    playerStats.push({
                        idx: pIdx,
                        avgX: totalX / count,
                        frameCount: count
                    });
                }
            }

            // Nach X-Position sortieren: links im Bild = kleinere X
            playerStats.sort((a, b) => a.avgX - b.avgX);

            return playerStats.map((p, i) => ({
                idx: p.idx,
                side: i === 0 ? 'left' : 'right', // Erster = links im Bild
                avgX: p.avgX,
                frameCount: p.frameCount,
                spielhand: null // Vom Labeler zu setzen
            }));
        }

        function renderPlayerPanel() {
            const panel = document.getElementById('ai-players');
            const list = document.getElementById('ai-players-list');

            if (aiDetectedPlayers.length === 0) {
                panel.classList.add('hidden');
                return;
            }

            panel.classList.remove('hidden');

            list.innerHTML = aiDetectedPlayers.map((player, i) => {
                const sideLabel = player.side === 'left' ? '‚¨Ö Links im Bild' : '‚û° Rechts im Bild';
                const posPercent = Math.round(player.avgX * 100);

                return `
                <div class="flex items-center gap-2 p-2 rounded-lg ${player.side === 'left' ? 'bg-blue-50 border border-blue-200' : 'bg-orange-50 border border-orange-200'}">
                    <div class="flex-1">
                        <div class="flex items-center gap-1 mb-1">
                            <span class="text-xs font-bold ${player.side === 'left' ? 'text-blue-700' : 'text-orange-700'}">
                                Spieler ${i + 1}
                            </span>
                            <span class="text-xs text-gray-500">${sideLabel}</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-1 mb-1" title="Position im Bild: ${posPercent}%">
                            <div class="h-1 rounded-full ${player.side === 'left' ? 'bg-blue-400' : 'bg-orange-400'}" style="width: ${posPercent}%; margin-left: 0;"></div>
                        </div>
                    </div>
                    <select class="ai-player-hand text-xs border rounded px-1 py-1" data-player-index="${i}">
                        <option value=""${!player.spielhand ? ' selected' : ''}>Auto</option>
                        <option value="right"${player.spielhand === 'right' ? ' selected' : ''}>Rechtsh.</option>
                        <option value="left"${player.spielhand === 'left' ? ' selected' : ''}>Linksh.</option>
                    </select>
                </div>
            `}).join('');

            // Spielhand-√Ñnderung Event-Handler
            list.querySelectorAll('.ai-player-hand').forEach(select => {
                select.addEventListener('change', () => {
                    const idx = parseInt(select.dataset.playerIndex);
                    aiDetectedPlayers[idx].spielhand = select.value || null;
                });
            });
        }

        // Nahe Erkennungen desselben Spielers zusammenf√ºhren.
        // Bei Aufschl√§gen erkennt die KI oft den Ballwurf UND den Schlag separat.
        // Wenn zwei Erkennungen desselben Spielers < MERGE_THRESHOLD_SEC auseinander liegen,
        // werden sie zu einer zusammengefasst (fr√ºhester Start, sp√§testes Ende, h√∂chste Konfidenz).
        const MERGE_THRESHOLD_SEC = 1.5;

        function mergeNearbyShots(shots) {
            if (shots.length <= 1) return shots;

            // Nach Startzeit sortieren
            const sorted = [...shots].sort((a, b) => a.startTime - b.startTime);
            const merged = [sorted[0]];

            for (let i = 1; i < sorted.length; i++) {
                const prev = merged[merged.length - 1];
                const curr = sorted[i];

                // Gleicher Spieler und zeitlich nah genug?
                if (prev.playerNum === curr.playerNum &&
                    (curr.startTime - prev.endTime) < MERGE_THRESHOLD_SEC) {
                    // Zusammenf√ºhren: Zeitfenster erweitern, h√∂here Konfidenz behalten
                    prev.endTime = Math.max(prev.endTime, curr.endTime);
                    if (curr.confidence > prev.confidence) {
                        prev.confidence = curr.confidence;
                        // Schlagtyp vom h√∂her-konfidenten √ºbernehmen
                        prev.shotType = curr.shotType;
                    }
                    // Serve hat Priorit√§t (Ballwurf + Schlag = Aufschlag)
                    if (curr.shotType.includes('serve') && !prev.shotType.includes('serve')) {
                        prev.shotType = curr.shotType;
                    }
                    prev.id = prev.id + '+merged';
                } else {
                    merged.push(curr);
                }
            }

            return merged;
        }

        // Rally-Logik: Schl√§ge sollten abwechselnd S1/S2 sein.
        // Ausnahmen: Aufschlag-Wiederholungen (Netz-Aufschlag = gleicher Spieler nochmal).
        // Algorithmus:
        // 1. Erster Schlag setzt den Startspieler
        // 2. Jeder folgende Schlag geh√∂rt dem anderen Spieler
        // 3. Aufschlag nach Aufschlag = gleicher Spieler (Netz/Fehl-Aufschlag)
        // 4. Aufschlag nach Nicht-Aufschlag = neuer Ballwechsel, Spieler ist wie erkannt
        function applyRallyAlternation(shots) {
            if (shots.length <= 1 || aiDetectedPlayers.length < 2) return shots;

            const result = [...shots];
            const p1Side = aiDetectedPlayers[0]?.side || 'left';
            const p2Side = aiDetectedPlayers[1]?.side || 'right';

            for (let i = 1; i < result.length; i++) {
                const prev = result[i - 1];
                const curr = result[i];
                const prevType = prev.correctedType || prev.shotType;
                const currType = curr.correctedType || curr.shotType;
                const isServe = currType.includes('serve');
                const prevIsServe = prevType.includes('serve');

                if (isServe && prevIsServe && prev.playerNum === curr.playerNum) {
                    // Aufschlag nach Aufschlag vom gleichen Spieler = Netz-Aufschlag, OK
                    continue;
                }

                if (isServe) {
                    // Neuer Ballwechsel: KI-Erkennung f√ºr den Aufschl√§ger beibehalten
                    continue;
                }

                // Normaler Schlag: muss den anderen Spieler haben als der vorherige
                const expectedPlayer = prev.playerNum === 1 ? 2 : 1;
                if (curr.playerNum !== expectedPlayer) {
                    curr.playerNum = expectedPlayer;
                    curr.playerSide = expectedPlayer === 1 ? p1Side : p2Side;
                    curr.rallyAdjusted = true; // Markierung dass Rally-Logik ge√§ndert hat
                }
            }

            return result;
        }

        // Klassifizierung mit aktuellen Spieler-Einstellungen neu ausf√ºhren
        function reclassifyWithPlayers() {
            if (!aiFormattedFrames || aiDetectedPlayers.length === 0) return;

            const duration = videoPlayer?.duration || 1;
            let rawSuggestions = [];

            // F√ºr jeden erkannten Spieler die Schl√§ge klassifizieren
            aiDetectedPlayers.forEach((player, playerNum) => {
                const options = {};
                if (player.spielhand) options.spielhand = player.spielhand;

                const analysis = classifyShots(aiFormattedFrames, player.idx, options);
                if (!analysis.shots || analysis.shots.length === 0) return;

                // Vorschl√§ge mit Spieler-Info erstellen
                analysis.shots.forEach((shot, i) => {
                    // Phasen-Timestamps nutzen falls verf√ºgbar, sonst Fallback ¬±0.3s
                    const phaseStart = shot.backswingTimestamp != null
                        ? Math.max(0, shot.backswingTimestamp - 0.05)
                        : Math.max(0, shot.timestamp - 0.3);
                    const phaseEnd = shot.followThroughTimestamp != null
                        ? Math.min(duration, shot.followThroughTimestamp + 0.05)
                        : Math.min(duration, shot.timestamp + 0.3);

                    rawSuggestions.push({
                        id: `ai-p${playerNum}-${i}`,
                        startTime: phaseStart,
                        endTime: phaseEnd,
                        contactTime: shot.contactTimestamp || shot.timestamp,
                        shotType: shot.shotType,
                        confidence: shot.confidence,
                        shotFrom: null,
                        shotTo: null,
                        shotResult: 'hit',
                        accepted: false,
                        correctedType: null,
                        dismissed: false,
                        playerNum: playerNum + 1,
                        playerSide: player.side
                    });
                });
            });

            // Nahe Erkennungen zusammenf√ºhren (verhindert Doppelerkennung bei Aufschl√§gen etc.)
            const merged = mergeNearbyShots(rawSuggestions);

            // Rally-Alternation anwenden (S1-S2-S1-S2...)
            aiSuggestions = applyRallyAlternation(merged);

            renderAISuggestions();
            renderTimeline();

            const mergedCount = rawSuggestions.length - merged.length;
            const mergeInfo = mergedCount > 0 ? `, ${mergedCount} zusammengef√ºhrt` : '';
            showToast(`${aiSuggestions.length} Schl√§ge erkannt (${aiDetectedPlayers.length} Spieler${mergeInfo})`, 'success');
        }

        async function runAIAnalysis() {
            if (!videoPlayer || !currentVideo) return;

            const analyzeBtn = document.getElementById('ai-analyze-btn');
            const progressDiv = document.getElementById('ai-progress');
            const progressText = document.getElementById('ai-progress-text');
            const progressPercent = document.getElementById('ai-progress-percent');
            const progressBar = document.getElementById('ai-progress-bar');

            // Pr√ºfen ob KI verf√ºgbar
            if (!isAIAvailable()) {
                showToast('KI-Analyse ist auf dieser Plattform nicht verf√ºgbar', 'error');
                return;
            }

            analyzeBtn.disabled = true;
            analyzeBtn.classList.add('opacity-50');
            progressDiv.classList.remove('hidden');

            aiAbortController = new AbortController();

            try {
                // 1. Modell laden
                progressText.textContent = 'Lade KI-Modell...';
                await loadModels((pct) => {
                    progressPercent.textContent = `${Math.round(pct)}%`;
                    progressBar.style.width = `${pct}%`;
                });

                // 2. Sicherstellen dass Video geladen ist
                if (videoPlayer.readyState < 2) {
                    progressText.textContent = 'Warte auf Video...';
                    await new Promise((resolve, reject) => {
                        const handler = () => { videoPlayer.removeEventListener('loadeddata', handler); resolve(); };
                        videoPlayer.addEventListener('loadeddata', handler);
                        setTimeout(() => reject(new Error('Video Timeout')), 10000);
                    });
                }

                const duration = videoPlayer.duration;
                if (!duration || duration <= 0) {
                    showToast('Video-Dauer nicht verf√ºgbar', 'error');
                    return;
                }

                // 3. Video analysieren (5 FPS)
                progressText.textContent = 'Analysiere Video...';
                progressBar.style.width = '0%';

                const rawFrames = await analyzeFrameRange(
                    videoPlayer, 0, duration, 5,
                    currentVideo.id,
                    (done, total) => {
                        const pct = Math.round((done / total) * 100);
                        progressPercent.textContent = `${pct}%`;
                        progressBar.style.width = `${pct}%`;
                        progressText.textContent = `Frame ${done}/${total}`;
                    },
                    aiAbortController.signal
                );

                if (aiAbortController.signal.aborted) {
                    showToast('Analyse abgebrochen', 'info');
                    return;
                }

                // 4. Frames ins richtige Format konvertieren und speichern
                aiFormattedFrames = rawFrames.map(f => ({
                    timestamp_seconds: f.timestamp,
                    poses: f.landmarks.map((lm, idx) => ({
                        landmarks: lm,
                        worldLandmarks: f.worldLandmarks?.[idx] || null
                    })),
                    player_count: f.playerCount
                }));

                // 5. Spieler identifizieren (nach Position im Bild)
                progressText.textContent = 'Erkenne Spieler...';
                aiDetectedPlayers = identifyPlayers(aiFormattedFrames);
                renderPlayerPanel();

                // 6. Schl√§ge klassifizieren (f√ºr alle Spieler)
                progressText.textContent = 'Klassifiziere Schl√§ge...';
                reclassifyWithPlayers();

            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('AI analysis error:', error);
                    showToast('KI-Analyse fehlgeschlagen: ' + error.message, 'error');
                }
            } finally {
                progressDiv.classList.add('hidden');
                analyzeBtn.disabled = false;
                analyzeBtn.classList.remove('opacity-50');
                aiAbortController = null;
            }
        }

        async function runTableBallDetection() {
            if (!videoPlayer || !currentVideo) return;

            const btn = document.getElementById('ai-table-ball-btn');
            const infoDiv = document.getElementById('ai-table-ball-info');

            btn.disabled = true;
            btn.classList.add('opacity-50');
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analysiere Farben...';

            try {
                const duration = videoPlayer.duration || 1;
                // Farbbasiert braucht kein ML-Modell, startet sofort
                const result = await analyzeTableAndBall(
                    videoPlayer, 0, duration, 2,
                    (done, total) => {
                        const pct = Math.round(done / total * 100);
                        btn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${pct}% (${done}/${total})`;
                    },
                    aiAbortController?.signal
                );

                aiTableBox = result.table;
                aiBallTrack = result.ballTrack;

                // Ergebnis anzeigen
                infoDiv.classList.remove('hidden');
                const tableInfo = document.getElementById('ai-table-info');
                const ballInfo = document.getElementById('ai-ball-info');

                if (aiTableBox) {
                    const conf = Math.round(aiTableBox.confidence * 100);
                    const colorLabel = aiTableBox.color === 'blue' ? 'blauer' : aiTableBox.color === 'green' ? 'gr√ºner' : '';
                    const sourceLabel = aiTableBox.source === 'color' ? 'Farberkennung' : 'Objekterkennung';
                    const w = Math.round(aiTableBox.width * 100);
                    const h = Math.round(aiTableBox.height * 100);
                    tableInfo.innerHTML = `<i class="fas fa-check-circle text-green-500"></i> <strong>${colorLabel} Tisch erkannt</strong> (${conf}% Frames, ${w}%x${h}% Bild, ${sourceLabel})`;
                } else {
                    tableInfo.innerHTML = '<i class="fas fa-times-circle text-red-400"></i> Kein Tisch erkannt ‚Äî Tisch muss blau oder gr√ºn sein und sichtbar im Bild';
                }

                const uniqueBallFrames = new Set(aiBallTrack.map(b => Math.round(b.time * 10))).size;
                if (uniqueBallFrames > 0) {
                    ballInfo.innerHTML = `<i class="fas fa-check-circle text-green-500"></i> <strong>Ball-Kandidaten</strong> in ${uniqueBallFrames} Frames gefunden (experimentell)`;
                } else {
                    ballInfo.innerHTML = '<i class="fas fa-info-circle text-yellow-500"></i> Kein Ball erkannt (TT-B√§lle sind sehr klein, Erkennung experimentell)';
                }

                renderTimeline();

                // Ergebnisse in DB speichern (alte werden automatisch gel√∂scht)
                try {
                    await saveTableBallResults(supabase, currentVideo.id, currentUser.id, aiTableBox, aiBallTrack);
                    showToast('Tisch- & Ballerkennung abgeschlossen und gespeichert', 'success');
                } catch (saveErr) {
                    console.warn('Could not save table/ball results to DB:', saveErr);
                    showToast('Tisch- & Ballerkennung abgeschlossen (nicht gespeichert)', 'success');
                }

            } catch (error) {
                console.error('Table/Ball detection error:', error);
                showToast('Erkennung fehlgeschlagen: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                btn.classList.remove('opacity-50');
                btn.innerHTML = '<i class="fas fa-table-tennis"></i> Tisch & Ball erkennen';
            }
        }

        // ===== Tisch-Kalibrierung (4-Ecken) =====

        function startCalibration() {
            if (!videoPlayer || !overlayCanvas) return;
            // Video pausieren f√ºr stabiles Bild
            videoPlayer.pause();
            calibrationMode = true;
            calibrationCorners = [];
            // Canvas klickbar machen
            overlayCanvas.style.pointerEvents = 'auto';
            overlayCanvas.style.cursor = 'crosshair';
            // UI
            document.getElementById('calibration-bar').classList.remove('hidden');
            document.getElementById('btn-calibrate-table').classList.add('hidden');
            updateCalibrationUI();
            drawOverlay();
        }

        function cancelCalibration() {
            calibrationMode = false;
            calibrationCorners = [];
            overlayCanvas.style.pointerEvents = 'none';
            overlayCanvas.style.cursor = '';
            document.getElementById('calibration-bar').classList.add('hidden');
            document.getElementById('btn-calibrate-table').classList.remove('hidden');
            drawOverlay();
        }

        function undoCalibrationCorner() {
            if (calibrationCorners.length > 0) {
                calibrationCorners.pop();
                updateCalibrationUI();
                drawOverlay();
            }
        }

        function updateCalibrationUI() {
            const count = calibrationCorners.length;
            document.getElementById('calibration-count').textContent = `${count}/4`;
            const labels = [
                'Klicke Ecke 1: Oben-Links des Tisches',
                'Klicke Ecke 2: Oben-Rechts des Tisches',
                'Klicke Ecke 3: Unten-Rechts des Tisches',
                'Klicke Ecke 4: Unten-Links des Tisches'
            ];
            document.getElementById('calibration-instruction').textContent =
                count < 4 ? labels[count] : 'Alle 4 Ecken gesetzt!';
        }

        function handleCalibrationClick(e) {
            if (!calibrationMode || calibrationCorners.length >= 4) return;

            // Klick-Position in normalisierte Video-Koordinaten (0-1) umrechnen
            const rect = overlayCanvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) / rect.width;
            const clickY = (e.clientY - rect.top) / rect.height;

            // Sicherstellen dass Klick im Bereich ist
            if (clickX < 0 || clickX > 1 || clickY < 0 || clickY > 1) return;

            calibrationCorners.push({ x: clickX, y: clickY });
            updateCalibrationUI();
            drawOverlay();

            // Nach 4 Ecken: Kalibrierung abschlie√üen
            if (calibrationCorners.length === 4) {
                finishCalibration();
            }
        }

        async function finishCalibration() {
            savedTableCorners = [...calibrationCorners];

            // Kalibrierung beenden
            calibrationMode = false;
            overlayCanvas.style.pointerEvents = 'none';
            overlayCanvas.style.cursor = '';
            document.getElementById('calibration-bar').classList.add('hidden');
            document.getElementById('btn-calibrate-table').classList.remove('hidden');
            // Tisch-Overlay automatisch aktivieren
            showTable = true;
            const tableBtn = document.getElementById('toggle-table');
            tableBtn.dataset.active = 'true';
            tableBtn.classList.remove('text-gray-400', 'border-gray-600');
            tableBtn.classList.add('bg-white', 'text-gray-800', 'border-white');
            drawOverlay();

            // In DB speichern
            if (currentVideo && currentUser && supabase) {
                try {
                    await saveTableCalibration(supabase, currentVideo.id, currentUser.id, savedTableCorners);
                    showToast('Tisch-Kalibrierung gespeichert', 'success');
                } catch (err) {
                    console.error('Failed to save calibration:', err);
                    showToast('Kalibrierung konnte nicht gespeichert werden', 'error');
                }
            }
        }

        async function saveTableCalibration(db, videoId, userId, corners) {
            // Alte Kalibrierung l√∂schen
            try {
                await db.from('video_ai_analyses')
                    .delete()
                    .eq('video_id', videoId)
                    .eq('analysis_type', 'table_calibration');
            } catch (e) { /* ignore */ }

            const { error } = await db.from('video_ai_analyses').insert({
                video_id: videoId,
                analysis_type: 'table_calibration',
                status: 'completed',
                processing_location: 'browser',
                model_name: 'manual_calibration',
                model_version: '1.0',
                results: {
                    corners: corners,
                    corner_labels: ['top_left', 'top_right', 'bottom_right', 'bottom_left']
                },
                summary: { corners_count: corners.length },
                created_by: userId
            });

            if (error) throw error;
        }

        async function loadTableCalibration(db, videoId) {
            const { data, error } = await db
                .from('video_ai_analyses')
                .select('results')
                .eq('video_id', videoId)
                .eq('analysis_type', 'table_calibration')
                .eq('status', 'completed')
                .order('created_at', { ascending: false })
                .limit(1)
                .single();

            if (error || !data) return null;
            return data.results?.corners || null;
        }

        // ===== Overlay-Zeichenfunktionen =====

        function drawOverlay() {
            if (!overlayCtx || !overlayCanvas) return;
            const w = overlayCanvas.width;
            const h = overlayCanvas.height;
            if (!w || !h) return;

            overlayCtx.clearRect(0, 0, w, h);

            // Kalibrierungs-Modus: Ecken und Preview zeichnen
            if (calibrationMode) {
                drawCalibrationOverlay(w, h);
            }

            // Tisch-Polygon aus Kalibrierung (permanent)
            if (showTable && savedTableCorners && savedTableCorners.length === 4) {
                drawTablePolygon(w, h);
            }
            // Fallback: Auto-erkannte Tisch-Box
            else if (showTable && aiTableBox) {
                drawTableBox(w, h);
            }

            // Ball zeichnen
            if (showBall && aiBallTrack.length > 0) {
                drawBallPositions(w, h);
            }

            // Skelett zeichnen
            if (showSkeleton && aiFormattedFrames) {
                drawSkeletons(w, h);
            }
        }

        function drawCalibrationOverlay(w, h) {
            const corners = calibrationCorners;
            const ctx = overlayCtx;

            // Halbtransparenter Hintergrund
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, w, h);

            // Verbindungslinien zwischen gesetzten Ecken
            if (corners.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(corners[0].x * w, corners[0].y * h);
                for (let i = 1; i < corners.length; i++) {
                    ctx.lineTo(corners[i].x * w, corners[i].y * h);
                }
                // Polygon schlie√üen wenn 4 Ecken gesetzt
                if (corners.length === 4) {
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(250, 204, 21, 0.15)';
                    ctx.fill();
                }
                ctx.strokeStyle = '#facc15';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Ecken-Punkte zeichnen
            const labels = ['OL', 'OR', 'UR', 'UL'];
            for (let i = 0; i < corners.length; i++) {
                const cx = corners[i].x * w;
                const cy = corners[i].y * h;

                // Punkt
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#facc15';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labels[i], cx, cy);
                ctx.textAlign = 'start';
                ctx.textBaseline = 'alphabetic';

                // Nummer daneben
                ctx.fillStyle = '#facc15';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(`${i + 1}`, cx + 12, cy - 8);
            }

            // N√§chste erwartete Position andeuten
            if (corners.length < 4 && corners.length > 0) {
                const nextLabels = ['Oben-Rechts', 'Unten-Rechts', 'Unten-Links'];
                const label = nextLabels[corners.length - 1];
                ctx.fillStyle = 'rgba(250, 204, 21, 0.5)';
                ctx.font = '14px sans-serif';
                ctx.fillText(`N√§chste: ${label}`, 10, h - 10);
            }
        }

        function drawTablePolygon(w, h) {
            const corners = savedTableCorners;
            const ctx = overlayCtx;

            // Polygon f√ºllen
            ctx.beginPath();
            ctx.moveTo(corners[0].x * w, corners[0].y * h);
            for (let i = 1; i < 4; i++) {
                ctx.lineTo(corners[i].x * w, corners[i].y * h);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(34, 197, 94, 0.08)';
            ctx.fill();

            // Rand zeichnen
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Mittellinie (zwischen Mitte oben und Mitte unten)
            const midTop = {
                x: (corners[0].x + corners[1].x) / 2 * w,
                y: (corners[0].y + corners[1].y) / 2 * h
            };
            const midBot = {
                x: (corners[3].x + corners[2].x) / 2 * w,
                y: (corners[3].y + corners[2].y) / 2 * h
            };
            ctx.beginPath();
            ctx.moveTo(midTop.x, midTop.y);
            ctx.lineTo(midBot.x, midBot.y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Ecken-Punkte
            for (let i = 0; i < 4; i++) {
                const cx = corners[i].x * w;
                const cy = corners[i].y * h;
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#22c55e';
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Label
            const labelX = corners[0].x * w;
            const labelY = corners[0].y * h - 8;
            ctx.fillStyle = '#22c55e';
            ctx.font = 'bold 13px sans-serif';
            ctx.strokeStyle = 'rgba(0,0,0,0.6)';
            ctx.lineWidth = 3;
            ctx.strokeText('Tisch (kalibriert)', labelX, labelY);
            ctx.fillText('Tisch (kalibriert)', labelX, labelY);
        }

        function drawTableBox(w, h) {
            const t = aiTableBox;
            const x = t.x * w;
            const y = t.y * h;
            const bw = t.width * w;
            const bh = t.height * h;

            // Halbtransparenter Hintergrund
            const color = t.color === 'green' ? 'rgba(34, 197, 94, 0.15)' : 'rgba(59, 130, 246, 0.15)';
            const borderColor = t.color === 'green' ? '#22c55e' : '#3b82f6';

            overlayCtx.fillStyle = color;
            overlayCtx.fillRect(x, y, bw, bh);

            overlayCtx.strokeStyle = borderColor;
            overlayCtx.lineWidth = 2;
            overlayCtx.setLineDash([6, 4]);
            overlayCtx.strokeRect(x, y, bw, bh);
            overlayCtx.setLineDash([]);

            // Label
            overlayCtx.fillStyle = borderColor;
            overlayCtx.font = 'bold 14px sans-serif';
            overlayCtx.fillText('Tisch', x + 4, y - 4);
        }

        function drawBallPositions(w, h) {
            if (!videoPlayer) return;
            const currentTime = videoPlayer.currentTime;

            // Ball-Positionen im Umkreis von ¬±0.3 Sekunden zum aktuellen Zeitpunkt anzeigen
            const nearBalls = aiBallTrack.filter(b => Math.abs(b.time - currentTime) < 0.3);

            for (let i = 0; i < nearBalls.length; i++) {
                const b = nearBalls[i];
                const bx = b.x * w;
                const by = b.y * h;
                const age = Math.abs(b.time - currentTime);
                const alpha = Math.max(0.3, 1 - age / 0.3);

                // Ball-Kreis
                overlayCtx.beginPath();
                overlayCtx.arc(bx, by, 8, 0, Math.PI * 2);
                overlayCtx.fillStyle = `rgba(255, 165, 0, ${alpha * 0.6})`;
                overlayCtx.fill();
                overlayCtx.strokeStyle = `rgba(255, 165, 0, ${alpha})`;
                overlayCtx.lineWidth = 2;
                overlayCtx.stroke();

                // Fadenkreuz
                overlayCtx.beginPath();
                overlayCtx.moveTo(bx - 12, by);
                overlayCtx.lineTo(bx + 12, by);
                overlayCtx.moveTo(bx, by - 12);
                overlayCtx.lineTo(bx, by + 12);
                overlayCtx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
                overlayCtx.lineWidth = 1;
                overlayCtx.stroke();
            }

            // Ball-Spur (letzte 1 Sekunde)
            const trailBalls = aiBallTrack
                .filter(b => b.time <= currentTime && b.time >= currentTime - 1.0)
                .sort((a, b) => a.time - b.time);

            if (trailBalls.length >= 2) {
                overlayCtx.beginPath();
                overlayCtx.moveTo(trailBalls[0].x * w, trailBalls[0].y * h);
                for (let i = 1; i < trailBalls.length; i++) {
                    overlayCtx.lineTo(trailBalls[i].x * w, trailBalls[i].y * h);
                }
                overlayCtx.strokeStyle = 'rgba(255, 165, 0, 0.4)';
                overlayCtx.lineWidth = 2;
                overlayCtx.setLineDash([3, 3]);
                overlayCtx.stroke();
                overlayCtx.setLineDash([]);
            }
        }

        function drawSkeletons(w, h) {
            if (!videoPlayer || !aiFormattedFrames) return;
            const currentTime = videoPlayer.currentTime;

            // N√§chsten Frame finden
            let bestFrame = null;
            let bestDist = Infinity;
            for (const frame of aiFormattedFrames) {
                const dist = Math.abs(frame.timestamp_seconds - currentTime);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestFrame = frame;
                }
            }

            // Nur zeichnen wenn der n√§chste Frame < 0.3s entfernt ist
            if (!bestFrame || bestDist > 0.3 || !bestFrame.poses) return;

            // Farben f√ºr Spieler
            const playerColors = ['#3b82f6', '#f97316']; // Blau, Orange

            bestFrame.poses.forEach((pose, playerIdx) => {
                if (!pose || !pose.landmarks) return;
                const lm = pose.landmarks;
                const color = playerColors[playerIdx] || '#ffffff';

                // Verbindungen zeichnen (Skelett-Linien)
                overlayCtx.strokeStyle = color;
                overlayCtx.lineWidth = 3;
                overlayCtx.globalAlpha = 0.8;

                for (const [startIdx, endIdx] of POSE_CONNECTIONS) {
                    const start = lm[startIdx];
                    const end = lm[endIdx];
                    if (!start || !end) continue;
                    if (start.visibility < 0.3 || end.visibility < 0.3) continue;

                    overlayCtx.beginPath();
                    overlayCtx.moveTo(start.x * w, start.y * h);
                    overlayCtx.lineTo(end.x * w, end.y * h);
                    overlayCtx.stroke();
                }

                // Keypoints zeichnen (Gelenke)
                const importantJoints = [
                    POSE_LANDMARKS.LEFT_SHOULDER, POSE_LANDMARKS.RIGHT_SHOULDER,
                    POSE_LANDMARKS.LEFT_ELBOW, POSE_LANDMARKS.RIGHT_ELBOW,
                    POSE_LANDMARKS.LEFT_WRIST, POSE_LANDMARKS.RIGHT_WRIST,
                    POSE_LANDMARKS.LEFT_HIP, POSE_LANDMARKS.RIGHT_HIP,
                    POSE_LANDMARKS.LEFT_KNEE, POSE_LANDMARKS.RIGHT_KNEE,
                    POSE_LANDMARKS.LEFT_ANKLE, POSE_LANDMARKS.RIGHT_ANKLE,
                    POSE_LANDMARKS.NOSE
                ];

                for (const idx of importantJoints) {
                    const kp = lm[idx];
                    if (!kp || kp.visibility < 0.3) continue;

                    const kx = kp.x * w;
                    const ky = kp.y * h;
                    const isWrist = idx === POSE_LANDMARKS.LEFT_WRIST || idx === POSE_LANDMARKS.RIGHT_WRIST;
                    const radius = isWrist ? 6 : 4;

                    overlayCtx.beginPath();
                    overlayCtx.arc(kx, ky, radius, 0, Math.PI * 2);
                    overlayCtx.fillStyle = isWrist ? '#ffffff' : color;
                    overlayCtx.fill();
                    overlayCtx.strokeStyle = isWrist ? color : 'rgba(0,0,0,0.5)';
                    overlayCtx.lineWidth = isWrist ? 3 : 1;
                    overlayCtx.stroke();
                }

                // Spieler-Label
                const nose = lm[POSE_LANDMARKS.NOSE];
                if (nose && nose.visibility > 0.3) {
                    overlayCtx.fillStyle = color;
                    overlayCtx.font = 'bold 16px sans-serif';
                    overlayCtx.strokeStyle = 'rgba(0,0,0,0.7)';
                    overlayCtx.lineWidth = 3;
                    overlayCtx.strokeText(`S${playerIdx + 1}`, nose.x * w - 10, nose.y * h - 15);
                    overlayCtx.fillText(`S${playerIdx + 1}`, nose.x * w - 10, nose.y * h - 15);
                }

                overlayCtx.globalAlpha = 1.0;
            });
        }

        function renderAISuggestions() {
            const container = document.getElementById('ai-suggestions');
            const list = document.getElementById('ai-suggestions-list');

            if (aiSuggestions.length === 0) {
                container.classList.add('hidden');
                return;
            }

            container.classList.remove('hidden');

            list.innerHTML = aiSuggestions.map((sug, index) => {
                const displayType = sug.correctedType || sug.shotType;
                const isBackhand = displayType.startsWith('backhand');
                const confPercent = Math.round(sug.confidence * 100);
                const confColor = confPercent >= 70 ? 'text-green-600' : confPercent >= 50 ? 'text-yellow-600' : 'text-red-600';
                const hasMultiplePlayers = aiDetectedPlayers.length > 1;
                const rallyIcon = sug.rallyAdjusted ? '<i class="fas fa-exchange-alt text-xs ml-0.5" title="Rally-Logik hat Spieler angepasst"></i>' : '';
                const playerBadge = sug.playerNum
                    ? (hasMultiplePlayers
                        ? `<button class="ai-sug-player text-xs px-1 rounded cursor-pointer hover:ring-1 hover:ring-gray-400 ${sug.playerSide === 'left' ? 'bg-blue-200 text-blue-800' : 'bg-orange-200 text-orange-800'}" data-index="${index}" title="Klick: Spieler wechseln">S${sug.playerNum}${rallyIcon}</button>`
                        : `<span class="text-xs px-1 rounded ${sug.playerSide === 'left' ? 'bg-blue-100 text-blue-700' : 'bg-orange-100 text-orange-700'}">S${sug.playerNum}</span>`)
                    : '';
                const durationMs = Math.round((sug.endTime - sug.startTime) * 1000);

                // Von/Nach/Ergebnis Auswahl
                const fromVal = sug.shotFrom || '';
                const toVal = sug.shotTo || '';
                const resultVal = sug.shotResult || 'hit';

                const dismissedClass = sug.dismissed ? 'opacity-50 line-through' : '';
                const bgClass = sug.dismissed ? 'bg-gray-100 border border-gray-300' : sug.accepted ? 'bg-green-50 border border-green-200' : 'bg-cyan-50 border border-cyan-200';

                return `
                <div class="ai-sug-item rounded-lg ${bgClass} ${dismissedClass}" data-index="${index}">
                    <div class="flex items-center gap-1 p-1.5">
                        <button class="ai-sug-jump text-xs text-gray-400 hover:text-cyan-600 px-1" data-time="${sug.startTime}" title="Zum Zeitpunkt springen">
                            <i class="fas fa-play"></i>
                        </button>
                        ${playerBadge}
                        <span class="text-xs font-mono text-gray-500 shrink-0">${formatTime(sug.startTime)}</span>
                        <span class="text-xs text-gray-300 shrink-0">${durationMs}ms</span>
                        <select class="ai-sug-type text-xs border rounded px-1 py-0.5 flex-1 ${isBackhand ? 'text-purple-700 bg-purple-50' : 'text-indigo-700 bg-indigo-50'}" data-index="${index}">
                            <option value="forehand_serve"${displayType === 'forehand_serve' ? ' selected' : ''}>VH Aufschlag</option>
                            <option value="forehand_topspin"${displayType === 'forehand_topspin' ? ' selected' : ''}>VH Topspin</option>
                            <option value="forehand_push"${displayType === 'forehand_push' ? ' selected' : ''}>VH Schupf</option>
                            <option value="forehand_block"${displayType === 'forehand_block' ? ' selected' : ''}>VH Block</option>
                            <option value="backhand_serve"${displayType === 'backhand_serve' ? ' selected' : ''}>RH Aufschlag</option>
                            <option value="backhand_topspin"${displayType === 'backhand_topspin' ? ' selected' : ''}>RH Topspin</option>
                            <option value="backhand_push"${displayType === 'backhand_push' ? ' selected' : ''}>RH Schupf</option>
                            <option value="backhand_block"${displayType === 'backhand_block' ? ' selected' : ''}>RH Block</option>
                        </select>
                        <span class="text-xs ${confColor} w-7 text-right" title="Konfidenz">${confPercent}%</span>
                        <button class="ai-sug-edit text-xs px-1 py-0.5 rounded bg-yellow-100 text-yellow-700 hover:bg-yellow-200" data-index="${index}" title="Im Formular bearbeiten">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button class="ai-sug-accept text-xs px-1.5 py-0.5 rounded ${sug.accepted ? 'bg-green-600 text-white' : 'bg-green-100 text-green-700 hover:bg-green-200'}" data-index="${index}" title="${sug.accepted ? '√úbernommen' : '√úbernehmen'}">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="ai-sug-dismiss text-xs px-1 py-0.5 rounded ${sug.dismissed ? 'bg-gray-500 text-white' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'}" data-index="${index}" title="Falsch erkannt (kein Schlag)">
                            <i class="fas fa-ban"></i>
                        </button>
                        <button class="ai-sug-delete text-xs text-red-400 hover:text-red-600 px-1" data-index="${index}" title="Verwerfen">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="flex items-center gap-1 px-1.5 pb-1.5">
                        <span class="text-xs text-gray-400 w-7">Von:</span>
                        <div class="flex gap-0.5">
                            <button class="ai-sug-from text-xs px-1.5 py-0.5 rounded border ${fromVal === 'vh' ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-from="vh">VH</button>
                            <button class="ai-sug-from text-xs px-1.5 py-0.5 rounded border ${fromVal === 'mitte' ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-from="mitte">M</button>
                            <button class="ai-sug-from text-xs px-1.5 py-0.5 rounded border ${fromVal === 'rh' ? 'bg-purple-600 text-white border-purple-600' : 'bg-white border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-from="rh">RH</button>
                        </div>
                        <span class="text-xs text-gray-300 mx-0.5">‚Üí</span>
                        <span class="text-xs text-gray-400 w-8">Nach:</span>
                        <div class="flex gap-0.5">
                            <button class="ai-sug-to text-xs px-1.5 py-0.5 rounded border ${toVal === 'vh' ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-to="vh">VH</button>
                            <button class="ai-sug-to text-xs px-1.5 py-0.5 rounded border ${toVal === 'mitte' ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-to="mitte">M</button>
                            <button class="ai-sug-to text-xs px-1.5 py-0.5 rounded border ${toVal === 'rh' ? 'bg-purple-600 text-white border-purple-600' : 'bg-white border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-to="rh">RH</button>
                        </div>
                        <div class="flex gap-0.5 ml-auto">
                            <button class="ai-sug-result text-xs px-1 py-0.5 rounded ${resultVal === 'hit' ? 'bg-green-600 text-white' : 'bg-white border border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-result="hit" title="Getroffen">‚úì</button>
                            <button class="ai-sug-result text-xs px-1 py-0.5 rounded ${resultVal === 'net' ? 'bg-orange-500 text-white' : 'bg-white border border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-result="net" title="Netz">N</button>
                            <button class="ai-sug-result text-xs px-1 py-0.5 rounded ${resultVal === 'out' ? 'bg-red-500 text-white' : 'bg-white border border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-result="out" title="Aus">A</button>
                            <button class="ai-sug-result text-xs px-1 py-0.5 rounded ${resultVal === 'miss' ? 'bg-gray-500 text-white' : 'bg-white border border-gray-300 hover:bg-gray-100'}" data-index="${index}" data-result="miss" title="Verfehlt">‚úó</button>
                        </div>
                    </div>
                </div>
            `}).join('');

            // Event-Handler f√ºr Vorschl√§ge
            list.querySelectorAll('.ai-sug-jump').forEach(btn => {
                btn.addEventListener('click', () => {
                    videoPlayer.currentTime = parseFloat(btn.dataset.time);
                });
            });

            list.querySelectorAll('.ai-sug-player').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    const sug = aiSuggestions[idx];
                    if (!sug || aiDetectedPlayers.length < 2) return;
                    // Spieler umschalten: S1 <-> S2
                    if (sug.playerNum === 1) {
                        sug.playerNum = 2;
                        sug.playerSide = aiDetectedPlayers[1]?.side || 'right';
                    } else {
                        sug.playerNum = 1;
                        sug.playerSide = aiDetectedPlayers[0]?.side || 'left';
                    }
                    renderAISuggestions();
                    renderTimeline();
                });
            });

            list.querySelectorAll('.ai-sug-type').forEach(select => {
                select.addEventListener('change', () => {
                    const idx = parseInt(select.dataset.index);
                    aiSuggestions[idx].correctedType = select.value;
                    renderAISuggestions();
                    renderTimeline();
                });
            });

            list.querySelectorAll('.ai-sug-from').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    aiSuggestions[idx].shotFrom = btn.dataset.from;
                    renderAISuggestions();
                });
            });

            list.querySelectorAll('.ai-sug-to').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    aiSuggestions[idx].shotTo = btn.dataset.to;
                    renderAISuggestions();
                });
            });

            list.querySelectorAll('.ai-sug-result').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    aiSuggestions[idx].shotResult = btn.dataset.result;
                    renderAISuggestions();
                });
            });

            list.querySelectorAll('.ai-sug-edit').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    editAISuggestionInForm(idx);
                });
            });

            list.querySelectorAll('.ai-sug-accept').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    acceptAISuggestion(idx);
                });
            });

            list.querySelectorAll('.ai-sug-dismiss').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    const sug = aiSuggestions[idx];
                    if (!sug) return;
                    sug.dismissed = !sug.dismissed;
                    if (sug.dismissed) sug.accepted = false;
                    renderAISuggestions();
                    renderTimeline();
                });
            });

            list.querySelectorAll('.ai-sug-delete').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index);
                    aiSuggestions.splice(idx, 1);
                    renderAISuggestions();
                    renderTimeline();
                });
            });
        }

        // Suggestion in die "Schlag markieren"-Form laden zum Bearbeiten
        let editingAISuggestionIndex = null;

        function editAISuggestionInForm(index) {
            const sug = aiSuggestions[index];
            if (!sug) return;

            editingAISuggestionIndex = index;
            const displayType = sug.correctedType || sug.shotType;

            // Video zum Zeitpunkt springen
            if (videoPlayer) videoPlayer.currentTime = sug.startTime;

            // Startzeit setzen
            document.getElementById('shot-start-min').value = Math.floor(sug.startTime / 60);
            document.getElementById('shot-start-sec').value = Math.floor(sug.startTime % 60);
            document.getElementById('shot-start-ms').value = Math.floor((sug.startTime % 1) * 1000);

            // Endzeit setzen
            document.getElementById('shot-end-min').value = Math.floor(sug.endTime / 60);
            document.getElementById('shot-end-sec').value = Math.floor(sug.endTime % 60);
            document.getElementById('shot-end-ms').value = Math.floor((sug.endTime % 1) * 1000);

            // Schlagtyp-Button aktivieren
            document.querySelectorAll('.shot-type-btn').forEach(b => {
                b.classList.remove('bg-indigo-600', 'bg-purple-600', 'text-white', 'border-indigo-600', 'border-purple-600');
            });
            const matchingBtn = document.querySelector(`.shot-type-btn[data-type="${displayType}"]`);
            if (matchingBtn) {
                const isBackhand = displayType.startsWith('backhand');
                matchingBtn.classList.add(isBackhand ? 'bg-purple-600' : 'bg-indigo-600', 'text-white');
            }

            // Von-Position setzen
            document.querySelectorAll('.from-btn').forEach(b => {
                b.classList.remove('bg-indigo-600', 'bg-purple-600', 'text-white');
            });
            if (sug.shotFrom) {
                const fromBtn = document.querySelector(`.from-btn[data-from="${sug.shotFrom}"]`);
                if (fromBtn) fromBtn.classList.add('bg-indigo-600', 'text-white');
            }

            // Nach-Position setzen
            document.querySelectorAll('.to-btn').forEach(b => {
                b.classList.remove('bg-indigo-600', 'bg-purple-600', 'text-white');
            });
            if (sug.shotTo) {
                const toBtn = document.querySelector(`.to-btn[data-to="${sug.shotTo}"]`);
                if (toBtn) toBtn.classList.add('bg-indigo-600', 'text-white');
            }

            // Ergebnis setzen
            document.querySelectorAll('.result-btn').forEach(b => {
                b.classList.remove('bg-green-600', 'bg-orange-500', 'bg-red-500', 'bg-gray-500', 'text-white');
                b.classList.add('bg-white');
            });
            const resultVal = sug.shotResult || 'hit';
            const resultBtn = document.querySelector(`.result-btn[data-result="${resultVal}"]`);
            if (resultBtn) {
                const colors = { 'hit': 'bg-green-600', 'net': 'bg-orange-500', 'out': 'bg-red-500', 'miss': 'bg-gray-500' };
                resultBtn.classList.remove('bg-white');
                resultBtn.classList.add(colors[resultVal], 'text-white');
            }

            // Hinweis anzeigen dass wir im Bearbeitungsmodus sind
            const addBtn = document.getElementById('add-shot-btn');
            addBtn.innerHTML = '<i class="fas fa-save"></i> KI-Vorschlag √ºbernehmen (bearbeitet)';
            addBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            addBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');

            // Zum Formular scrollen
            addBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
            showToast('KI-Vorschlag im Formular geladen - bearbeiten und √ºbernehmen', 'info');
        }

        function resetEditMode() {
            editingAISuggestionIndex = null;
            const addBtn = document.getElementById('add-shot-btn');
            addBtn.innerHTML = '<i class="fas fa-plus"></i> Schlag hinzuf√ºgen';
            addBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
            addBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        }

        function acceptAISuggestion(index) {
            const sug = aiSuggestions[index];
            if (!sug || sug.accepted || sug.dismissed) return;

            const finalType = sug.correctedType || sug.shotType;

            // In die Schlag-Liste √ºbernehmen
            currentShots.push({
                id: `ai-accepted-${Date.now()}-${index}`,
                startTime: sug.startTime,
                endTime: sug.endTime,
                shotType: finalType,
                shotFrom: sug.shotFrom,
                shotTo: sug.shotTo,
                shotResult: sug.shotResult,
                saved: false,
                aiGenerated: true,
                aiOriginalType: sug.shotType,
                aiCorrected: sug.correctedType !== null && sug.correctedType !== sug.shotType,
                playerNum: sug.playerNum || null,
                playerSide: sug.playerSide || null
            });

            sug.accepted = true;
            renderShotsList();
            renderAISuggestions();
            renderTimeline();
        }

        function acceptAllAISuggestions() {
            let count = 0;
            aiSuggestions.forEach((sug, i) => {
                if (!sug.accepted && !sug.dismissed) {
                    acceptAISuggestion(i);
                    count++;
                }
            });
            const dismissedCount = aiSuggestions.filter(s => s.dismissed).length;
            const dismissedInfo = dismissedCount > 0 ? `, ${dismissedCount} als falsch markiert` : '';
            showToast(`${count} Vorschl√§ge √ºbernommen${dismissedInfo}`, 'success');
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const colors = {
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-yellow-500',
                info: 'bg-indigo-500'
            };

            const toast = document.createElement('div');
            toast.className = `${colors[type]} text-white px-4 py-2 rounded-lg shadow-lg transform transition-all duration-300 translate-x-full`;
            toast.textContent = message;

            container.appendChild(toast);
            setTimeout(() => toast.classList.remove('translate-x-full'), 10);
            setTimeout(() => {
                toast.classList.add('translate-x-full');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
    </script>
    <script type="module">
        import { initI18n, translatePage, setupAutoTranslate } from '/js/i18n.js';
        await initI18n();
        translatePage();
        setupAutoTranslate();
    </script>
</body>
</html>
